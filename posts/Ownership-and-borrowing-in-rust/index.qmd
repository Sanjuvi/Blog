---
title: "Ownership and Borrowing in Rust"
author: "Sanjeevi "
date: "2023-2-28"
categories: [Code,Theory]
image: "image.jpg"
---

Before we can talk about this weird concept in rust, why do we have them in the first place? Most modern languages solve problems with existing languages like java, JavaScript, objective c, and python. Before reading this blog post, I want you to read my previous blog post about [zero cost abstraction](https://sanjuvi github.io/Blog/posts/Zero-cost-abstraction/) and [memory safety](https://sanjuvi.github.io/Blog/posts Memory-Unsafety/) or some knowledge of why c/c++ still dominates the world even modern language emerges.

Ownership is a restriction on rust to prevent temporal memory error (like Use after Free, dangling pointer), double free by statically i.e at **compile time** without using any runtime when the program running. This is an important characteristic for many reasons. As we will see, how ownership aid in ergonomics use of language features that no other mainstream language could think of. 

Modern c++ introduces **RAII-Resource Allocation Is Initialization** i.e the objects(files, resources) or raw pointers encapsulated inside class objects. When the object goes out of scope, its destructor is called automatically. This is deterministic, not employing a garbage collector. Even though modern c++ encourages you to use it,

  - 1) RAII-based smart pointers for managing resources instead of using raw pointers.
  - 2) STL(Standard Template Libraries) abstraction to get rid of low-level details in loops, and programming.
  - 3) Closure to capture the enclosing environment. But rust closure is way more capable and safe than c++ closure.

These APIs are still possible to misuse. Read this blog post about [Why modern c++ still causes you a memory error](https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/). I'm not here to blame c++ in favor of rust. I'm just saying that for people like me who came from dynamic programming languages like python,**rust compiler is more backup than a c++ compiler as the errors contain rich error information and also suggesting to fix it this felt so amazing ** when writing system level programming for the first time in their life. But I definitely admit that rust is not a beginner-friendly language when starting but the pay off definitely worth it when considering all things around us surrounded by
software where safety is **First Class** important.

In rust, every variable has a unique owner except **Smart pointers**. That is, the owner is responsible for cleaning up the memory once it's done with it and also ensures that no other references to that object are when cleaning up that memory, a task that the borrow checker checks using the **lifetime**.

Moveable types are moved to a new variable when assigned where as copyable types are copied when assigned to a new variable. How does rust know whether the type is Copy or Move? This is where traits come in. The trait is like Haskell's type classes, swift's protocols, or java,c# interfaces. Here we only consider two traits that are in the std library copy and drop trait. If the type implements the Copy trait, then when assigned to a new variable it's **cloned implicitly** i.e deep copy. So that we can use the variable after it's assigned and the borrow checker won't complain.

```rust
//prevent the compiler warning about unused variables.
#[allow(unused_variables)] 
fn main(){

 let int=34;
 let int_copy =int;

 let boolean=true;
 let boolean_copy=boolean;
  
 let float=2.1;
 let float_copy=float;

 let character ='M';
 let character_copy=character;
 
 let strr="Sanjeevi";  
 let strr_copy =strr;

 let array=[1,2,34]; 
 let array_copy =array;

//only true when all the types inside the tuple themselves are copy types
 let tuple=(int,boolean,float,character); 
 let tuple_copy=tuple;

//no error since they are copy types.
 println!("{int} {float} \n{boolean} {character} {strr} 
        \n{array:?} {tuple:?}");
}
```

But when the type own resources or calling drop when goes out of scope, then it's **moved implicitly**, that's why when trying to use the old one results in compile error that **use of moved value**.**Rust way of doing implicit and explicit** doesn't cost anything since deep copying the stack allocated is cheap but heap allocated not. So we have to explicitly about deep copying the heap data by cloning them. **Custom types** are moved implicitly. Here move means the stack pointing to the heap-allocated data was moved not the heap itself i.e the actual data, so here moves are efficient since we only move the stack(ptr,len, capacity) not the actual data residing in Heap. Why this is efficient because  

- **1)ptr**-pointer to the heap 
- **2) len**-length of currently allocated elements, 
- **3) Capacity**-size of the allocation is stored in the stack.

These are the metadata to provide an abstraction to correctly allocate and deallocate the data without the manual involvement of memory allocation as in c/c++.

```rust
#[allow(unused_variables)]
fn main(){
 
 let vector = vec!["Same type of heap allocated data","Hi ,rustaceans"];
 let vector_move = vector;

let string = String::from("Mutable heap allocated string type");
let string_move = string;
 
 let vector_of_integers = vec![25,2,2023];
 //we have to explicit
 let clone_of_vector_of_integers = vector_of_integers.clone(); 
 
 //only true when all the types inside the tuple themselves are copy types
let tuple=(vector,vector_of_integers,string); 
let tuple_move=tuple;

//no error since they are copy types.
println!("{vector:?} \n{string:?}\n{vector_of_integers:?}\n 
         {clone_of_vector_of_integers:?} \n{tuple:?}");
}

```

But ownership is more restrictive than it has to be. Can we use references like c++ references but safely? Absolutely we can. Enter borrowing, instead of taking ownership we can temporarily borrow it. There is a distinction here. The borrow is either immutable ***or*** mutable depending on the signature. Like move types, mutable borrow moves the mutable borrows if assigned to new variables since they are **unique**.Instead of **cleaning the memory** when the scope ends,**we end the borrow** since we don't own the data. Like copy types, immutable borrow copy the borrows, because multiple immutable shared, borrows are permitted as long as there is no overlapping mutable borrow sounds like concurrency right? Yet this same restriction allows rust to prevent **data race at compile time**, yes,**at compile time**.

```rust
fn main(){
 
 let mut data = vec![1,2,3,4];
//Multiple immutable references or aliases are permitted in the same scope
 let immutable_reference_1 = &data;//reference to whole collection
 let immutable_reference_1_copy = immutable_reference_1;
 let immutable_reference_2 =&data[0];//reference to first element
 //we can't mutate data behind immutable references just like variables
// *immutable_reference_2=23; immutable by default
//so do the references.
  let mutable_reference =&mut data;

//the value is moved here since they are unique i.e not disable
  let mutable_reference_move=mutable_reference;
  //mutable_reference doesn't exist at this point
  // *mutable_reference=vec![5,6,7,8,9,10];

  //here we derefencing using * operator just like c++
   *mutable_reference_move=vec![5,6,7,8,9,10];
   println!("{:?}",data);
}
```
Try uncommenting the lines and see what your friend(the compiler) tells you about that.

Ownership and borrowing are crucial to understanding the rest of the rust language features. They are applied to local variables, function calls, methods, threads, data structures, and closures.

```rust
fn main(){

  let mut vector:Vec<i32> =vec![999,666];
  //the order of the calling function is important.We can alternate b/w 
  //immutable and mutable one since they are not
  //overlapping each other and we can call as many times as we want as long as the vector is not moved
  mutable_borrowing(&mut vector);
  immutable_borrowing(&vector);

  //Here the vector is moved and the new owner is new_owner.
  let new_owner=takes_and_return(vector);
  //we can't call any function that accepts the vector variable
  moves_and_takes_ownership(new_owner);
   //immutable_borrowing(&vector);
  //mutable_borrowing(&mut vector);
    
}
fn immutable_borrowing(a:&Vec<i32>){
    println!("{:?}",a);
}
fn mutable_borrowing(a:&mut Vec<i32>){
    a.push(45);
}
 //We can also return ownership to the caller
fn takes_and_return(a:Vec<i32>) -> Vec<i32>{
       a
}
fn moves_and_takes_ownership(_a:Vec<i32>){
 //new_owner is cleaned here not in the main  
}

```

Look at the function signature carefully. Just by looking at them, we can reason about what might they do. The second function call takes an immutable reference so we can guarantee that there is no mutation taken inside the function body. This is the same for methods where the self is the first parameter of the method.

 >**&self** -immutable borrow.

 >**&mut self** -Mutable borrow so that we can mutate the self values inside the method body.

 >**self** -Takes ownership, after that, we are no longer able to call any methods defined on the self if the return type is unit type i.e returns nothing.

***Ownership/borrowing in Closure and the Move keyword***:

The closure is an anonymous function that captures the surrounding environment either mutably or immutably depending on how it's used inside the closure or moved inside the closure when **Move** keyword is used. As usual, the same rules apply. Move types moved to a new owner, copy types just deep copy the value.

```rust
fn main() {
  let mut vector =vec![1,2,3];
  let mut mutable_closure = ||vector.push(56); //implicitly mutably borrowed,
  //because of the push method called inside the closure 
  mutable_closure(); //calling closure.
  let immutable_closure=||{println!("{:?}",vector);};//immutably borrowed since we are reading.
  immutable_closure();
  let ownership_closure =move ||vector; //the closure is takes ownership by moving explicitly 
  // println!("{:?}",m); //Use of moved value
  println!("{:?}",takes_closure());
 let copy_type:f64 =std::f64::consts::PI;
 let moving = move||copy_type;
 println!("{} {}",copy_type,moving());
}
```

These same procedures help to avoid accessing the objects once the object sends it to another thread via channels.

Region-based or Scope based memory/resource management i.e the values created and destroyed in lexical scope where they created and also prevent you to cause temporal memory safety. Even though region-based memory management is used to manage memory, rust uses the same idea to release the lock, close the files and sockets, and ends the borrows, and any other resources **implicitly without human intervention as humans are good at forgetting things**. This feels automatic and ergonomic since we don't need explicitly call unlock on a mutex, close on file, or socket. This is really **phenomenal**.Rust knows well **where** to do ***implicit*** actions like cleaning resources and where to do ***explicit*** actions like numerical conversion, and cloning on heap data.


***Even more Weirdo***:

Cyclone is a research programming language that introduces the concept of **linear types(Ownership, in the case of rust)** in a programming language. For more expressive capability linear types supports *sub-region types*,i.e borrowing. Rust inherits ideas from the cyclone including ownership, and borrowing. Linear and subtypes avoid the ***Spooky action at a distance***.That's why the order of calling function important.

Generics is a way to reduce code duplication and provide better abstraction with static and dynamic dispatch. Normally generics in c++ are abstract over a type and const. But in rust, we have ***generic over lifetime***  or ***generic over sub-linear types***. These sophisticated implementations make rust have a steep learning curve than any other programming language that came to exist except for some advanced type system languages like Haskell. 

*Swift* also has a proposal for integrating ownership into the language to manage memory efficiently.

**Project Verona**, a reasearch language that leverage the linear types and other methods to build reliable concurrent application for the cloud.

**References**:

[Rust official Book about Ownership](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)

[Cyclone](https://cyclone.thelanguage.org/wiki/)

[Swift proposal for ownership](https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md)

[Project Verona](https://www.microsoft.com/en-us/research/project/project-verona/)