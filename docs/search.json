[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Memory safety, what it is?\n\n\n\nCode\n\n\nTheory\n\n\n\n\n\n\n\nSanjeevi\n\n\nJan 2, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat is Rust?\n\n\n\nTheory\n\n\n\n\n\n\n\nSanjeevi\n\n\nJan 1, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZero Cost Abstraction\n\n\n\nTheory\n\n\n\n\n\n\n\nSanjeevi\n\n\nDec 31, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Rust-pl/index.html",
    "href": "posts/Rust-pl/index.html",
    "title": "What is Rust?",
    "section": "",
    "text": "Rust is an emerging new system programming language. But what is a system programming language? A system programming language is like any other programming language except it provides full control over hardware, manual memory management, abstraction without overhead like c++ to implement system-level software, and runs on bare metal(Without any operating system). So why another system programming language since we have c/c++?\nWhat others tell about rust\nThe quotes below are from Microsoft Azure CTO Mark Russinovich in Twitter.\nRust is most loved by developers for five years row, a survey conducted by StackOverflow.\nnow look at the feature, the language provides.\nZero cost abstraction Abstraction in the system programming language doesn’t impose any additional overhead. Because it’s a system programming language introducing abstraction means reducing the development time, less code, expressive.More on here.\nAOT(Ahead of Time)\nRust compiler(rustc) is a gatekeeper to refuse a code that violates the compiler rules without even running a program thus the execution and startup speed is low once an executable file is generated.\nGuaranteed memory safety\nMove Semantics\nFearless concurrency.\nTools and productivity\nCargo -a build tool and a package manager like Pip for python,Npm fo js but for a system PL.\nClippy command used to find non-idiomatic rust like ESLinter for js.\nRustfmt command line tool to standardize coding style like pretty quick for js.\nRustup -Command line tool to install rust, rust components cargo,targets for cross-compilation, change the rustc version(stable,nightly,beta)\nRust Language Server(rls) used in intelligence IDE to provide syntax highlighting,code completion, pointing errors.\nRust Docs includes std library documentation, rust book, rust reference book when installing rust locally.\nRustDoc Generating documents embedded in rust source code via ‘///’ and then rendering on Doc.rs\nBuild in testing framework via test macros.\nModule system to manage large programs.\nBecause rust is a system programming language it supports conditional compilation,staticlib,dynamic link library.\nRust playground for playing with the language instantly in the web browser without installing rust locally.\nRust is a modern system programming language in addition to memory safe without using Garbage Collector. Is modern in the sense that these features are available in high-level dynamic programming languages not implemented in system programming languages(In terms of their safe use). Functional programming features are included (In the context of Haskell-a pure functional programming language)\nOther Features and Community\nSupports UTF-8 out of the box. Thus we can use more languages other than English. We can use emojis, scientific symbols, and other foreign languages.\nErgonomics to use language features than in the c/c++ counterparts.\nGenerics Reduce code duplication. Supports static dispatch along with compiler optimization and virtual dispatch via trait object at runtime.\nHygienic Macros-To generate boilerplate rust code for you , expanded when compiling so your code looks clean.\nClosure anonymous function.You can do an interesting thing with them without worrying about safety.\nRobust error handling strategies through Result & Option Type,using from ,into traits through ? operator.You never forgot to check error as the compiler forces you to do it ,the exhaustive nature of pattern matching.\nCrates.io a package registry for rust opensource libraries which cargo uses interanlly when building.\nBackward compatibility-This is important for evolving language feature as well as not breaking the code due to introducing new features into the language.This is reason why c/C++ barely introduces any major features or it will break the old code since it’s already span millions of lines of code in production.\nAutomatic scoped management for memory ,non_memory resources,locks,smart pointers are phenomenal since no human intervention is needed and also no runtime cost for that(More on that later).It’s RAII(Resource acquistion is initialization) principle from c++ for managing resources.\nRust Foundation is backed by big players that include Microsoft, Meta, Dropbox, Arm, Google, Amazon ,Shopify and others.Rust is a future-proof language.\nCompile errors contain rich information about what went wrong ,where that happened if code doesn’t compile and also suggests fixing that.This is important since rust introduces unique concepts Like ownership, borrowing,lifetime to rule out use after free, double free, dangling pointer, iterator invalidation,concurrency bugs at compile time.Don’t worry if those words are strange to you as they are explained in next blog post with rust code examples.Rust includes documentation about compile errors.\nRust wasm-bindgen library generate Webassembly.It’s a portable runtime for web, desktop, cloud, and blockchain where isolation and startup time is important. Rust has the best toolchain for web assembly than other languages. Web assembly runtime wasmtime, Cranelift itself is written in rust.\nBecause most of the errors are moved to compile time ,they are unlikely to crash at runtime and thus reliable for embedded systems reliable.Like haskell once it’s compiled it’s just work.\nLast but not least Rust is a green language i.e it’s very energy efficient after c.It’s important characteristic to consider since most of the world communicates through software.It’s impact is huge since IoT is on scale of billions thus reducing carbon footprints as well as providing safety.In the case of cloud computing writing software in rust means low carbon footprints like c but safety as well as less cloud bills as rust consume less memories.\nI think that rust is going to be a programming language that c++ creator anticipated in his paper “History of c++” at end of the paper.\nThe trade off that accepts before rust came:\nSpeed, safety,Easy to use-Pick any two.Language tends to provide safety, easy of use like python,java,js but not speed. Languages like c/c++ provide speed but unsafe.For Rust -Pick three but at what cost.Rust puts lot of restrictions on the programmer side so it’s essential to learn foundational concepts of rust upfront to successfully compile the rust code. This is very cumbersome if you are coming from dynamic programming languages like python,java script,ruby.Stay patient,listen to the compiler and fix it."
  },
  {
    "objectID": "posts/Rust-pl/index.html#resources-for-further-learning-about-rust",
    "href": "posts/Rust-pl/index.html#resources-for-further-learning-about-rust",
    "title": "What is Rust?",
    "section": "Resources for further learning about rust",
    "text": "Resources for further learning about rust\nOpen the link in a new tab by holding ‘ctrl’ and then click the link,if you are using a mouse then just click a rolling button.\nRust official Website\nFree high quality Rust book\nProgramming rust book\nWhy scientist turns into rust by Nature\nWhy rust so popular by stackoverflow\nStability Without stagnation\nRust Ergonomics\nSeamless Integration with c\nHistory of c++\nWhy Discord is switching from Go to Rust.\nSafe System Programming in Rust.\nEnergy efficiency of Rust by amazon blog"
  },
  {
    "objectID": "posts/Zero-cost-abstraction/index.html",
    "href": "posts/Zero-cost-abstraction/index.html",
    "title": "Zero Cost Abstraction",
    "section": "",
    "text": "Zero cost abstraction is a memory model for the system programming language that provides abstraction equivalent to handwritten low-level code without any additional overhead, proposed by Stroustrup in his paper Abstraction and C++ machine model. Let’s decompose them to explain their properties.\nZero:\nIt’s still costly but compared to other high-level languages(Python, Java, C#) they have little overhead when using virtual dispatch. Once the c/c++ compiler emits the assembly from the source code through GCC or LLVM the compiler is no longer needed which means we can distribute executable files without the end user installing c/c++.Whereas in dynamic programming languages the source code and the language runtime must always sit behind to run the program. Just because we have lots of memory that doesn’t mean use all of that, that’s what garbage collectors do. Whereas in embedded systems memory is measured in KiloBytes rather than GigaBytes, TeraBytes in PC, supercomputers in that GC is not an option other than using c/c++ or now rust. It’s fast as the hardware allowed.\nCost:\nEvery computation we perform has a cost associated with it, and how many resources(time and space) are needed to run a particular kind of task? Garbage-collected languages take more memory than necessary than manual memory management languages like c,c++, and rust.\nAbstraction :"
  },
  {
    "objectID": "posts/Zero-cost-abstraction/index.html#other-languages-that-are-used-in-embedded-systems",
    "href": "posts/Zero-cost-abstraction/index.html#other-languages-that-are-used-in-embedded-systems",
    "title": "Zero Cost Abstraction",
    "section": "Other languages that are used in embedded systems:",
    "text": "Other languages that are used in embedded systems:\nAda D Ivory"
  },
  {
    "objectID": "posts/Zero-cost-abstraction/index.html#cpu-chip-architecture",
    "href": "posts/Zero-cost-abstraction/index.html#cpu-chip-architecture",
    "title": "Zero Cost Abstraction",
    "section": "CPU Chip Architecture",
    "text": "CPU Chip Architecture\nEach CPU architecture has different assembly instructions, some are backward compatible others don’t. The compiler is a complex piece of software that does the heavy work of converting high-level concepts to architecture-specific assembly. Below are the most used CPU architectures and their 32 and 64-bit variants.\n\nIntel\nAMD\nArm\nPowerPC(IBM)\nAlpha\nApple Silicon(Only available in Apple products)\nRisc -v(Opensource Instruction Set Architecture(ISA)))\n\nIt’s misleading when people say c++ is platform-dependent, but java has a famous quote that “Write once, run anywhere”.A lot of the complexity is abstracted away from the programmer by the java runtime libraries.Java Runtime converts platform-independent byte code into machine-specific instruction at runtime.\nIf Manual memory management is more efficient then why do we have GCed language in the first place? The software runs the world, it is important to write software that is memory-safe since writing memory-safety software in a system programming language leads to vulnerability because of the way the language is designed. Lots of series vulnerabilities are found in c/c++ code bases.GCed language prefers safety over runtime performance. But rust came to break that tradeoff as we will see in the next article."
  },
  {
    "objectID": "posts/Zero-cost-abstraction/index.html#references",
    "href": "posts/Zero-cost-abstraction/index.html#references",
    "title": "Zero Cost Abstraction",
    "section": "References",
    "text": "References\n\nZero cost abstraction in Rust blog\nAbstraction and C++ machine model stroustrup 2005"
  },
  {
    "objectID": "posts/Memory-Unsafety/index.html",
    "href": "posts/Memory-Unsafety/index.html",
    "title": "Memory safety, what it is?",
    "section": "",
    "text": "A snippet from PROSSIMO\n\nMemory safety is a property of some programming languages that prevent programmers from introducing certain types of bugs related to how memory is used. Since memory safety bugs are often security issues, memory-safe languages are more secure than languages that are not memory safe.\n\nWhy memory safety is a big deal?\n\n70% of the vulnerabilities Microsoft assigns a CVE(Common Vulnerability Exposures) each year continue to be memory safety issues. –Microsoft Security Response Centre\n\n\nAround 70% of our high-severity security bugs are memory unsafety problems (that is, mistakes with C/C++ pointers). Half of those are use-after-free bugs. \n\nRaw pointers are root cause of the memory safety violation since allocating heap data involves pointers.Raw pointer as the name suggest ,carry no information other than pointing to memory.So ownership,lifetime of a pointer not controlled by compiler.They are too unrestricted,this is useful for interacting with hardware since the hardware is inherently unsafe but safe through abstraction-like types, that’s why rust has Unsafe escape hatch to break the compiler restriction.\nMemory allocations or pointers are ergonomics to use in rust than in c/c++ and also memory safe.There is no explicit equivalent new/delete or malloc/free keyword to allocate memory on the heap.Allocation and deallocation of memories in rust is automated by the compiler at compile time.Rust provides an abstraction for the allocation of heap memory.\nAdvances in type theories help to mitigate memory related errors statically by the type systems without using runtime like garbage collectors.Now look at how rust-type systems prevent memory-related errors by statically i.e without actually running a program.\nMemory Related Bugs\n\nUsing uninitialized variable\nNull pointers\nBuffer over-read and over-write\nInteger Overflow\nUse after free\nDouble free\nMemory leak\n\nThe above errors are mitigated by memory-safe languages which use Garbage Collector though not all. What’s so unique about rust is that these errors are ruled out at compile time except overflow which is determined at runtime.This is an important distinction that makes rust different from garage collected and c/c++.Don’t worry about the rust syntax now. Use this link to execute the code yourself in the browser.\nUse of Uninitialized Variable\nIf you declare a variable and it’s uninitialized if the initial value is not given by the programmer. The uninitialized variable contains random values or may be private data.GCed language uses control flow analysis to prevent using uninitialized variables.Rust does the same. In rust the variable must be initialized before it’s used.This is true for structs and enums constructors.\nfn main(){\n    let m:i32;\n    //m=10;\n    println!(\"{}\",m);\n}\nYou get a compile-time error.The type annotation is needed here since without initializing the variable with a value,rust won’t infer the type of the variable.\nNull pointers Is a pointer that points to nothing.It’s useful when something is may be not there or maybe there like Schrödinger’s cat.But it’s not enforced by the compiler,forgot to handle the possible results in a crash or silently continuing with wrong inputs since in c/c++ implicitly converts between types.Even in GCed languages at runtime i.e it will prevent further processing even when the subsequent task is not depend on them. There is no equivalent of c-NULL or c++ nullpointer or go nil in rust.It is mitigated through the type system.Rust uses a enum type to encode the logic of a null pointer.\nenum Option<T>{\nSome(T),\nNone\n}\nHere enum is a sum type i.e either this variant or another variant not both unlike struct.So we can’t dereference like this is pointer, try to do is compile the error. We won’t accidentally forget to miss another variant (some or none).The pattern must be exhaustive i.e cover everything otherwise compiler issues an error, not a warning.This is true for as long as we rely rust abstraction.If we are not handling errors then they are guaranteed to be non-null values.\nfn main(){\nlet m=vec![1,2,3,4,5];\nprintln!(\"{:?}\",m.get(5));//it returns none if the index if out of bounds otherwise returns some with elements.\n//println!(\"{:?}\",m[5]); //This causes panic,this is a runtime error as in python.\nlet i=Some(5);\nmatch i{\nsome(i)=>println!(\"{i}\"),\n\n}\n}\nBuffer Overflow\nAccessing elements that are not part of your data, whether it is stored on stack or heap, is a memory error. It will lead to security vulnerability since we were reading or writing memory that is not part of our data. Let’s try to access elements both from stack-allocated and heap-allocated data in rust. Notes on what is stack and heap, if you are curious what they are.\nfn main(){\n    let stack_data = [0,1,2,3,4];\n    let heap_data = vec![0,1,2,3,4];\n  //  let stack_invalid_data = stack_data[5];//Length of the array is 5 and it's zero-indexed.\n  //  println!(\"{}\",stack_invalid_data);\n    let heap_invalid_data = heap_data[5];\n    println!(\"{}\",heap_invalid_data);\n}\nRust will panic at runtime. Panicking in rust is to stop the program immediately instead of continuing further with the wrong data.\nInteger Overflow\nInteger overflow is like the buffer overflow. Integers have limits that how many values can represent depending on the bits used to represent that. There are two integer types signed and unsigned.Signed integer(negative numbers) only represent values from \\(-{2}^ {(n-1)} to +2^ {(n-1)}-1\\) and unsigned integer represent values from \\(0 to 2^n -1\\).For eg, 8-bit signed integers only represent -128 to 127 values but unsigned integers represent more values than signed integers since they start from zero.Rust std libraries provide min and max values of the signed and unsigned integers. Let’s use that..\nfn main(){\n   let signed_8bit_min = i8::MIN;\n   let signed_8bit_max = i8::MAX;\n   let unsigned_64bit_min = u64::MIN;\n   let unsigned_64bit_max = u64::MAX; \n   //Only 8,6,32,64,128 bits are available for integer\n   println!(\"{}\",signed_8bit_Max+1);\n}\nAdding or subtracting one to the maximum or minimum values of any integer bits respectively causes overflow.In debug mode rust compiles with an error message.\nUse after free\nThis bug happens when accessing heap or dynamically allocated data after it is freed or after released to the operating system.In c/c++ accessing values after freeing memory cause segfaults.But in rust it’s compiling time error.Why this is a bug,once heap memory is released to the operating system the memory is uninitialized or used by another program once it’s freed. So accessing the freed memory crashes the system, which causes segfaults in c/c++ when run.How rust prevents this at compile.Let’s look at the code below,\nfn main(){\n  let s=String::from(\"Rustacean\");\n  call(s);\n  println!(\"{}\",s);//Here we access s which is freed when the call scope ends.\n}\nfn call(s:String){\n    s.push('s');\n}//When the owner of heap allocated data goes out of scope,it's freed automatically.\nBecause of the single ownership restriction,when s is passed to fn the function call takes ownership so the function is responsible for cleaning the memory.But we try to access in the main function after it’s transferred or moved ,which is forbidden by the rust compiler. Rust won’t compile this code.\nDangling pointer\nReturning or storing a reference to the pointer whether it is stack allocated or heap allocated is a bad idea,when they are used after freeing the memory in c/c++.This is called dangling pointers since they point at invalid memory.But rust refuses to compile at all with this bug.\n\n//Returning reference to the caller\nfn main(){\n    let m=call();//pointing at anywhere if rust allowed\n    println!(\"{}\",m);\n}\nfn call()->&'static String{\n    let m=String::from(\"Dangling Pointer\");\n    &m\n}//This point the m is freed\n//storing reference and used after it's freed\nfn main(){\n\n    let m=String::from(\"Dangling\");\n    let s=&m;\n    drop(m);//explicitly freed\n    //m.push_str(\"Fourth\"); //Mutable access\n    println!(\"{}\",s);//Here s is not valid so rust reject this code\n}\nDouble free \nThe double free error happens when heap-allocated memory calls free or delete on that memory and then we try to free that memory again eg: Calling two free() in c or two delete() in c++.Why the heck we want to free the memory twice, humans are not machine,in large code bases programmers free the memory twice by accident. It will crash the program with segfaults because when first call to free ,it will clear the data in that location then it stores the different data in that location when some program requests memory from the operating system allocator, so after calling the second free on the same data will clear the data which may cause another program to crash and using that memory to have undefined behavior.Rust prevents this by having single ownership rule i.e every variable exactly has one owner except smart pointer types.If we assign the movable type to a new variable,the new variable is the new owner and invalidates the old one.Let’s demonstrate how rust avoids double free.\nfn main(){\n    let m=String::from(\"Hello,Fellows\");//here heap allocated data initialized.\n    let n=m;//here m is moved to n,now m is uninitialized.exactly one drop is called when the owner goes out of scope.\n    println!(\"{}-{}\",m,n);\n}//here only n will freed implicitly by the compiler ,not both m and n.\nfn main(){\n    let m=vec![1,2,3,5];\n    drop(m);//explicitly freed once\n    drop(m);//try to clean the memory twice ,but rust complies with 'Use of moved value'\n}\nDrop is the rust equivalent of free, delete in c++. The rust compiler inserts the drop automatically when the owner goes out of scope.(Scope -a region where memory accesses are valid). This bug does not happen in GCed language where the GC only cleans the memory when there is no reference to that object but it’s not predictable.\nMemory leak:\nIn c/c++ forgetting to release the memory to the os once we have done with it resulted in memory leaks. Manual memory management is efficient because we can use larger memory and then release the memory by calling delete at predictable point in code so that we can use memory for the further task without exhausting the system memory.But forgetting to that prevents other programs to use the resources.Look at the below code ,looks like the file is not closed and not handling failure…\nuse std::fs::File;\nuse std::io::prelude::*;\nfn main() {\n\ncreate_file();\n\n}\nfn create_file()->std::io::Result<()>{\n    let mut file=File::create(\"text.txt\")?;\n    file.write(b\"There is no need to close file explicitly as there is no close method \nThe file close implicitly when the scope ends\")?;\n    Ok(())\n}\nThere are no leaks here. Rust uses scoped management for releasing memory and other resources when they are goes out of scope. This is how rust manages sockets,locks,files.Garabge collector only help you with memory errors not resources.In python with statement used to release the resources when the scope ends,other wise it’s still uses that file until the program terminates. Other languages provide similar mechanisms to handle resources other than memories.The ? operator is an ergonomic way to handle failure in rust,on success it returns nothing i.e () ,on failure it returns early with error without further processing.\nIterator Invalidation\nCreate a data structure, pass them to the function as two parameters. The same data structure tries to add elements to it at each loop sate but it’s infinitely run because the loop counts is increased each time a loop enters the body. But it’s not the problem though, it is used after freed memory whenever the vector doesn’t have space to store it , it will move to a new place then a shared pointer reads invalid memory if we are allowed this operation it’s writing data to other data structures.\nfn main(){\n let mut v:Vec<usize> = vec![1,2,3];\n let v1:Vec<usize> = vec![1,23,3];\n call( &mut v, &v1);//passing mutable and immutable references\n //call( &mut v,&v);\n println!(\" {:?} \", v);\n    }\nfn call(s: &mut Vec<usize>,s1: &Vec<usize>){\n    for i in s1.iter() {\n        s.push(*i);\n    }\n}\nThe above code tries to add elements of v1 to v and compiles successfully. But what if we pass the same vector to the function? Try uncommenting the second function call call(), then look at what the compiler says.It says,\n\ncannot borrow v as immutable because it is also borrowed as mutable.\n\nWhat is remarkable is that just looking at the function signature rust would able to detect this. Compile the above code by removing the for loop inside a function body. Rust has a restriction that either One mutable reference(write) to the object or Multiple immutable reference(read) at a time.\nWhy this is a bug? There is two things that happen if a program is allowed, either the loop run infinitely because each time the for loop runs it increases the length of the vector which is infinite since pushing elements to the same vector increases the length, or crashes the program , pushing more elements to the vector increase the capacity which in turns allocate more memory from operating system then move the data to a new location this is same as use after free. Run this python code in your editor or online python interpreter\ndata=[1,2,4]\nfor i in data: #reads the data i.e iterating \n    data.append(i) #after this the list length is increased thus for loop iteration.\nConcurrency Bug:\nConcurrency bugs are related to memory bugs where without synchronization the memory access is incorrect because of a race condition where multiple threads are accessing the same memory. Writing concurrency programs is not an easy task,only experienced programmers can write still buggy though. But functional programming like haskell,erlang,elixir or imperative like go provide a better abstraction for writing concurrency without much experience in concurrency programs. But they are still misused if we are not careful.\nRust forces you to use synchronization for shared memory before sharing between threads. Because of the restriction on Aliasing and Mutatation  we can write low level concurrency as in c/c++ but with much more safety and guarantee.In below code, there is no way to access the data inside the mutex without locking it first which gives exclusive access. Note that this is a single-threaded code.\nuse std::sync::Mutex;\nfn main(){\n    let i=Mutex::new(45);\n   *i+=10; //type `Mutex<{integer}>` cannot be dereferenced,We are forced to use lock on mutex\n    let l=i.lock();//Even though we lock the data inside of mutex,we still can't acess the data unless    handling the error since the return type is Result which must be hadled via pattern matching or call unwrap to get the value inside\n    //let mut l=i.lock().unwrap();//without mut we can't mutate the data \n    *l+=10;//\n    println!(\"{:?}\",l);\n}\nBut where do we unlock the mutex? We don’t, when the scope ends the lock is unlocked automatically. The same procedure is to help to automatically close the file above.Just in three lines of code ,we can see that how rust prevent you to compile the code without using APIs properly.Rust supports more than shared memory model concurrency.\nBut Gc Language doesn’t save you from concurrency bugs, other resources like files, sockets,databases without putting a restriction on the design of the language like immutable data structure, lifetime of objects or scoped objects. But they are not forced by the language runtime thus it’s easy to make mistakes.\nBeing memory safety doesn’t mean being immune to security-related problems. What about the other 30 percent of vulnerability in Microsoft and chromium, which must be mitigated by source code analysis and extensive testing?\nJust using memory-safe languages makes certain memory-related bugs not existed in the first place. But when writing performance-critical software, the choices include c/c++ but they are not safe by default. Now we have rust that is safe and runs on bare metal as it lacks a runtime.\nAndroid chose rust to write new native code and kotlin, java at a high level.\nApple creates swift as memory safe and modern with a deterministic approach to memory management.\nRust in Android.\nRust in chromium\nFearless concurrency with rust.\nMicrosoft chooses Rust for writing new code.\nWhy Memory safety is important\nSeriousness of NULL\nC++ Rules to follow in order to doesn’t cause undefined behavior at runtime. In case of rust,the compiler has your back i.e bugs are caught by the compiler."
  }
]