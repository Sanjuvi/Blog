<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sanjeevi">
<meta name="dcterms.date" content="2023-02-28">

<title>Home - Ownership and Borrowing in Rust</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Home - Ownership and Borrowing in Rust">
<meta property="og:description" content="Before we can talk about this weird concept in rust, why do we have them in the first place?">
<meta property="og:image" content="https://sanjuvi.github.io/Blog/posts\Ownership-and-borrowing-in-rust\image.jpg">
<meta property="og:site-name" content="Home">
<meta name="twitter:title" content="Home - Ownership and Borrowing in Rust">
<meta name="twitter:description" content="Before we can talk about this weird concept in rust, why do we have them in the first place?">
<meta name="twitter:image" content="https://sanjuvi.github.io/Blog/posts\Ownership-and-borrowing-in-rust\image.jpg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Home</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/PySanjeevi/"><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/sanjeevi-%E0%AE%9A%E0%AE%9E%E0%AF%8D%E0%AE%9A%E0%AF%80%E0%AE%B5%E0%AE%BF-01a7b813b/"><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Sanjuvi/"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Ownership and Borrowing in Rust</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Code</div>
                <div class="quarto-category">Theory</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Sanjeevi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 28, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Before we can talk about this weird concept in rust, why do we have them in the first place? Most modern languages solve problems with existing languages like java, JavaScript, objective c, and python. Before reading this blog post, I want you to read my previous blog post about <a href="https://sanjuvi%20github.io/Blog/posts/Zero-cost-abstraction/">zero cost abstraction</a> and <a href="https://sanjuvi.github.io/Blog/posts%20Memory-Unsafety/">memory safety</a> or some knowledge of why c/c++ still dominates the world even modern language emerges.</p>
<p>Ownership is a restriction on rust to prevent temporal memory error (like Use after Free, dangling pointer), double free by statically i.e at <strong>compile time</strong> without using any runtime when the program running. This is an important characteristic for many reasons. As we will see, how ownership aid in ergonomics use of language features that no other mainstream language could think of.</p>
<p>Modern c++ introduces <strong>RAII-Resource Allocation Is Initialization</strong> i.e the objects(files, resources) or raw pointers encapsulated inside class objects. When the object goes out of scope, its destructor is called automatically. This is deterministic, not employing a garbage collector. Even though modern c++ encourages you to use it,</p>
<ul>
<li><ol type="1">
<li>RAII-based smart pointers for managing resources instead of using raw pointers.</li>
</ol></li>
<li><ol start="2" type="1">
<li>STL(Standard Template Libraries) abstraction to get rid of low-level details in loops, and programming.</li>
</ol></li>
<li><ol start="3" type="1">
<li>Closure to capture the enclosing environment. But rust closure is way more capable and safe than c++ closure.</li>
</ol></li>
</ul>
<p>These APIs are still possible to misuse. Read this blog post about <a href="https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/">Why modern c++ still causes you a memory error</a>. I’m not here to blame c++ in favor of rust. I’m just saying that for people like me who came from dynamic programming languages like python,<strong>rust compiler is more backup than a c++ compiler as the errors contain rich error information and also suggesting to fix it this felt so amazing </strong> when writing system level programming for the first time in their life. But I definitely admit that rust is not a beginner-friendly language when starting but the pay off definitely worth it when considering all things around us surrounded by software where safety is <strong>First Class</strong> important.</p>
<p>In rust, every variable has a unique owner except <strong>Smart pointers</strong>. That is, the owner is responsible for cleaning up the memory once it’s done with it and also ensures that no other references to that object are when cleaning up that memory, a task that the borrow checker checks using the <strong>lifetime</strong>.</p>
<p>Moveable types are moved to a new variable when assigned where as copyable types are copied when assigned to a new variable. How does rust know whether the type is Copy or Move? This is where traits come in. The trait is like Haskell’s type classes, swift’s protocols, or java,c# interfaces. Here we only consider two traits that are in the std library copy and drop trait. If the type implements the Copy trait, then when assigned to a new variable it’s <strong>cloned implicitly</strong> i.e deep copy. So that we can use the variable after it’s assigned and the borrow checker won’t complain.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//prevent the compiler warning about unused variables.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>allow<span class="at">(</span>unused_variables<span class="at">)]</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> int<span class="op">=</span><span class="dv">34</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> int_copy <span class="op">=</span>int<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> boolean<span class="op">=</span><span class="cn">true</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> boolean_copy<span class="op">=</span>boolean<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> float<span class="op">=</span><span class="dv">2.1</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> float_copy<span class="op">=</span>float<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> character <span class="op">=</span><span class="ch">'M'</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> character_copy<span class="op">=</span>character<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> strr<span class="op">=</span><span class="st">"Sanjeevi"</span><span class="op">;</span>  </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> strr_copy <span class="op">=</span>strr<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> array<span class="op">=</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">34</span>]<span class="op">;</span> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> array_copy <span class="op">=</span>array<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">//only true when all the types inside the tuple themselves are copy types</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> tuple<span class="op">=</span>(int<span class="op">,</span>boolean<span class="op">,</span>float<span class="op">,</span>character)<span class="op">;</span> </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> tuple_copy<span class="op">=</span>tuple<span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co">//no error since they are copy types.</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a> <span class="pp">println!</span>(<span class="st">"{int} {float} </span><span class="sc">\n</span><span class="st">{boolean} {character} {strr} </span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="st">        </span><span class="sc">\n</span><span class="st">{array:?} {tuple:?}"</span>)<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>But when the type own resources or calling drop when goes out of scope, then it’s <strong>moved implicitly</strong>, that’s why when trying to use the old one results in compile error that <strong>use of moved value</strong>.<strong>Rust way of doing implicit and explicit</strong> doesn’t cost anything since deep copying the stack allocated is cheap but heap allocated not. So we have to explicitly about deep copying the heap data by cloning them. <strong>Custom types</strong> are moved implicitly. Here move means the stack pointing to the heap-allocated data was moved not the heap itself i.e the actual data, so here moves are efficient since we only move the stack(ptr,len, capacity) not the actual data residing in Heap. Why this is efficient because</p>
<ul>
<li><strong>1)ptr</strong>-pointer to the heap</li>
<li><strong>2) len</strong>-length of currently allocated elements,</li>
<li><strong>3) Capacity</strong>-size of the allocation is stored in the stack.</li>
</ul>
<p>These are the metadata to provide an abstraction to correctly allocate and deallocate the data without the manual involvement of memory allocation as in c/c++.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>allow<span class="at">(</span>unused_variables<span class="at">)]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> vector <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">"Same type of heap allocated data"</span><span class="op">,</span><span class="st">"Hi ,rustaceans"</span>]<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> vector_move <span class="op">=</span> vector<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> string <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Mutable heap allocated string type"</span>)<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> string_move <span class="op">=</span> string<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> vector_of_integers <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">25</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">2023</span>]<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a> <span class="co">//we have to explicit</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> clone_of_vector_of_integers <span class="op">=</span> vector_of_integers<span class="op">.</span>clone()<span class="op">;</span> </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a> <span class="co">//only true when all the types inside the tuple themselves are copy types</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tuple<span class="op">=</span>(vector<span class="op">,</span>vector_of_integers<span class="op">,</span>string)<span class="op">;</span> </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tuple_move<span class="op">=</span>tuple<span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">//no error since they are copy types.</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">"{vector:?} </span><span class="sc">\n</span><span class="st">{string:?}</span><span class="sc">\n</span><span class="st">{vector_of_integers:?}</span><span class="sc">\n</span><span class="st"> </span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="st">         {clone_of_vector_of_integers:?} </span><span class="sc">\n</span><span class="st">{tuple:?}"</span>)<span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>But ownership is more restrictive than it has to be. Can we use references like c++ references but safely? Absolutely we can. Enter borrowing, instead of taking ownership we can temporarily borrow it. There is a distinction here. The borrow is either immutable <strong><em>or</em></strong> mutable depending on the signature. Like move types, mutable borrow moves the mutable borrows if assigned to new variables since they are <strong>unique</strong>.Instead of <strong>cleaning the memory</strong> when the scope ends,<strong>we end the borrow</strong> since we don’t own the data. Like copy types, immutable borrow copy the borrows, because multiple immutable shared, borrows are permitted as long as there is no overlapping mutable borrow sounds like concurrency right? Yet this same restriction allows rust to prevent <strong>data race at compile time</strong>, yes,<strong>at compile time</strong>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">mut</span> data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">//Multiple immutable references or aliases are permitted in the same scope</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> immutable_reference_1 <span class="op">=</span> <span class="op">&amp;</span>data<span class="op">;</span><span class="co">//reference to whole collection</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> immutable_reference_1_copy <span class="op">=</span> immutable_reference_1<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> immutable_reference_2 <span class="op">=&amp;</span>data[<span class="dv">0</span>]<span class="op">;</span><span class="co">//reference to first element</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a> <span class="co">//we can't mutate data behind immutable references just like variables</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">// *immutable_reference_2=23; immutable by default</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">//so do the references.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mutable_reference <span class="op">=&amp;</span><span class="kw">mut</span> data<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">//the value is moved here since they are unique i.e not disable</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mutable_reference_move<span class="op">=</span>mutable_reference<span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">//mutable_reference doesn't exist at this point</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// *mutable_reference=vec![5,6,7,8,9,10];</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">//here we derefencing using * operator just like c++</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>   <span class="op">*</span>mutable_reference_move<span class="op">=</span><span class="pp">vec!</span>[<span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">10</span>]<span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>   <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span>data)<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Try uncommenting the lines and see what your friend(the compiler) tells you about that.</p>
<p>Ownership and borrowing are crucial to understanding the rest of the rust language features. They are applied to local variables, function calls, methods, threads, data structures, and closures.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">mut</span> vector<span class="op">:</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="op">=</span><span class="pp">vec!</span>[<span class="dv">999</span><span class="op">,</span><span class="dv">666</span>]<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">//the order of the calling function is important.We can alternate b/w </span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">//immutable and mutable one since they are not</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">//overlapping each other and we can call as many times as we want as long as the vector is not moved</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  mutable_borrowing(<span class="op">&amp;</span><span class="kw">mut</span> vector)<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  immutable_borrowing(<span class="op">&amp;</span>vector)<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">//Here the vector is moved and the new owner is new_owner.</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> new_owner<span class="op">=</span>takes_and_return(vector)<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">//we can't call any function that accepts the vector variable</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  moves_and_takes_ownership(new_owner)<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>   <span class="co">//immutable_borrowing(&amp;vector);</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">//mutable_borrowing(&amp;mut vector);</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> immutable_borrowing(a<span class="op">:&amp;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>)<span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span>a)<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> mutable_borrowing(a<span class="op">:&amp;</span><span class="kw">mut</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>)<span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>push(<span class="dv">45</span>)<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a> <span class="co">//We can also return ownership to the caller</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> takes_and_return(a<span class="op">:</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;{</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>       a</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> moves_and_takes_ownership(_a<span class="op">:</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>)<span class="op">{</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a> <span class="co">//new_owner is cleaned here not in the main  </span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Look at the function signature carefully. Just by looking at them, we can reason about what might they do. The second function call takes an immutable reference so we can guarantee that there is no mutation taken inside the function body. This is the same for methods where the self is the first parameter of the method.</p>
<blockquote class="blockquote">
<p><strong>&amp;self</strong> -immutable borrow.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>&amp;mut self</strong> -Mutable borrow so that we can mutate the self values inside the method body.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>self</strong> -Takes ownership, after that, we are no longer able to call any methods defined on the self if the return type is unit type i.e returns nothing.</p>
</blockquote>
<p><strong><em>Ownership/borrowing in Closure and the Move keyword</em></strong>:</p>
<p>The closure is an anonymous function that captures the surrounding environment either mutably or immutably depending on how it’s used inside the closure or moved inside the closure when <strong>Move</strong> keyword is used. As usual, the same rules apply. Move types moved to a new owner, copy types just deep copy the value.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">mut</span> vector <span class="op">=</span><span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">mut</span> mutable_closure <span class="op">=</span> <span class="op">||</span>vector<span class="op">.</span>push(<span class="dv">56</span>)<span class="op">;</span> <span class="co">//implicitly mutably borrowed,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">//because of the push method called inside the closure </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  mutable_closure()<span class="op">;</span> <span class="co">//calling closure.</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> immutable_closure<span class="op">=||{</span><span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span>vector)<span class="op">;};</span><span class="co">//immutably borrowed since we are reading.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  immutable_closure()<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ownership_closure <span class="op">=</span><span class="kw">move</span> <span class="op">||</span>vector<span class="op">;</span> <span class="co">//the closure is takes ownership by moving explicitly </span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// println!("{:?}",m); //Use of moved value</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span>takes_closure())<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> copy_type<span class="op">:</span><span class="dt">f64</span> <span class="op">=</span><span class="pp">std::</span><span class="dt">f64</span><span class="pp">::consts::</span>PI<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> moving <span class="op">=</span> <span class="kw">move</span><span class="op">||</span>copy_type<span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a> <span class="pp">println!</span>(<span class="st">"{} {}"</span><span class="op">,</span>copy_type<span class="op">,</span>moving())<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These same procedures help to avoid accessing the objects once the object sends it to another thread via channels.</p>
<p>Region-based or Scope based memory/resource management i.e the values created and destroyed in lexical scope where they created and also prevent you to cause temporal memory safety. Even though region-based memory management is used to manage memory, rust uses the same idea to release the lock, close the files and sockets, and ends the borrows, and any other resources <strong>implicitly without human intervention as humans are good at forgetting things</strong>. This feels automatic and ergonomic since we don’t need explicitly call unlock on a mutex, close on file, or socket. This is really <strong>phenomenal</strong>.Rust knows well <strong>where</strong> to do <strong><em>implicit</em></strong> actions like cleaning resources and where to do <strong><em>explicit</em></strong> actions like numerical conversion, and cloning on heap data.</p>
<p><strong><em>Even more Weirdo</em></strong>:</p>
<p>Cyclone is a research programming language that introduces the concept of <strong>linear types(Ownership, in the case of rust)</strong> in a programming language. For more expressive capability linear types supports <em>sub-region types</em>,i.e borrowing. Rust inherits ideas from the cyclone including ownership, and borrowing. Linear and subtypes avoid the <strong><em>Spooky action at a distance</em></strong>.That’s why the order of calling function important.</p>
<p>Generics is a way to reduce code duplication and provide better abstraction with static and dynamic dispatch. Normally generics in c++ are abstract over a type and const. But in rust, we have <strong><em>generic over lifetime</em></strong> or <strong><em>generic over sub-linear types</em></strong>. These sophisticated implementations make rust have a steep learning curve than any other programming language that came to exist except for some advanced type system languages like Haskell.</p>
<p><em>Swift</em> also has a proposal for integrating ownership into the language to manage memory efficiently.</p>
<p><strong>Project Verona</strong>, a reasearch language that leverage the linear types and other methods to build reliable concurrent application for the cloud.</p>
<p><strong>References</strong>:</p>
<p><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Rust official Book about Ownership</a></p>
<p><a href="https://cyclone.thelanguage.org/wiki/">Cyclone</a></p>
<p><a href="https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md">Swift proposal for ownership</a></p>
<p><a href="https://www.microsoft.com/en-us/research/project/project-verona/">Project Verona</a></p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>