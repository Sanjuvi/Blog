<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sanjeevi">
<meta name="dcterms.date" content="2023-01-02">

<title>Home - Memory safety, what it is?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Home - Memory safety, what it is?">
<meta property="og:description" content="A snippet from PROSSIMO">
<meta property="og:image" content="https://sanjuvi.github.io/Blog/posts\Memory-Unsafety\image.jpg">
<meta property="og:site-name" content="Home">
<meta name="twitter:title" content="Home - Memory safety, what it is?">
<meta name="twitter:description" content="A snippet from PROSSIMO">
<meta name="twitter:image" content="https://sanjuvi.github.io/Blog/posts\Memory-Unsafety\image.jpg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Home</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/PySanjeevi/"><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/sanjeevi-%E0%AE%9A%E0%AE%9E%E0%AF%8D%E0%AE%9A%E0%AF%80%E0%AE%B5%E0%AE%BF-01a7b813b/"><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Sanjuvi/"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Memory safety, what it is?</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Code</div>
                <div class="quarto-category">Theory</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Sanjeevi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 2, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>A snippet from <a href="https://www.memorysafety.org/docs/memory-safety/">PROSSIMO</a></p>
<blockquote class="blockquote">
<p>Memory safety is a property of some programming languages that prevent programmers from introducing certain types of bugs related to how memory is used. Since memory safety bugs are often security issues, memory-safe languages are more secure than languages that are not memory safe.</p>
</blockquote>
<p>Why memory safety is a big deal?</p>
<blockquote class="blockquote">
<p>70% of the vulnerabilities Microsoft assigns a CVE(Common Vulnerability Exposures) each year continue to be memory safety issues. –Microsoft Security Response Centre</p>
</blockquote>
<blockquote class="blockquote">
<p>Around 70% of our high-severity security bugs are memory unsafety problems (that is, mistakes with C/C++ pointers). Half of those are use-after-free bugs. <a href="https://www.chromium.org/Home/chromium-security/memory-safety/"></a></p>
</blockquote>
<p>Raw pointers are root cause of the memory safety violation since allocating heap data involves pointers.Raw pointer as the name suggest ,carry no information other than pointing to memory.So ownership,lifetime of a pointer not controlled by compiler.They are too unrestricted,this is useful for interacting with hardware since the hardware is inherently unsafe but safe through abstraction-like types, that’s why rust has <strong>Unsafe</strong> escape hatch to break the compiler restriction.</p>
<p>Memory allocations or pointers are ergonomics to use in rust than in c/c++ and also memory safe.There is no explicit equivalent new/delete or malloc/free keyword to allocate memory on the heap.Allocation and deallocation of memories in rust is automated by the compiler at compile time.Rust provides an abstraction for the allocation of heap memory.</p>
<p>Advances in type theories help to mitigate memory related errors statically by the type systems without using runtime like garbage collectors.Now look at how rust-type systems prevent memory-related errors by statically i.e without actually running a program.</p>
<p><strong>Memory Related Bugs</strong></p>
<ul>
<li>Using uninitialized variable</li>
<li>Null pointers</li>
<li>Buffer over-read and over-write</li>
<li>Integer Overflow</li>
<li>Use after free</li>
<li>Double free</li>
<li>Memory leak</li>
</ul>
<p>The above errors are mitigated by memory-safe languages which use <strong>Garbage Collector</strong> though not all. What’s so unique about rust is that these errors are ruled out at compile time except overflow which is determined at runtime.This is an important distinction that makes rust different from garage collected and c/c++.Don’t worry about the rust syntax now. Use this <a href="https://play.rust-lang.org/">link</a> to execute the code yourself in the browser.</p>
<p><strong>Use of Uninitialized Variable</strong></p>
<p>If you declare a variable and it’s uninitialized if the initial value is not given by the programmer. The uninitialized variable contains random values or may be private data.GCed language uses control flow analysis to prevent using uninitialized variables.Rust does the same. In rust the variable must be initialized before it’s used.This is true for structs and enums constructors.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">:</span><span class="dt">i32</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//m=10;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>m)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You get a compile-time error.The type annotation is needed here since without initializing the variable with a value,rust won’t infer the type of the variable.</p>
<p><strong>Null pointers</strong> Is a pointer that points to nothing.It’s useful when something is may be not there or maybe there like Schrödinger’s cat.But it’s not enforced by the compiler,forgot to handle the possible results in a crash or silently continuing with wrong inputs since in c/c++ implicitly converts between types.Even in GCed languages at runtime i.e it will prevent further processing even when the subsequent task is not depend on them. There is no equivalent of c-NULL or c++ nullpointer or go nil in rust.It is mitigated through the type system.Rust uses a enum type to encode the logic of a null pointer.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="dt">Option</span><span class="op">&lt;</span>T<span class="op">&gt;{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cn">Some</span>(T)<span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cn">None</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here enum is a sum type i.e either this variant or another variant not both unlike struct.So we can’t dereference like this is pointer, try to do is compile the error. We won’t accidentally forget to miss another variant (some <strong>or</strong> none).The pattern must be exhaustive i.e cover everything otherwise compiler issues an error, not a warning.This is true for as long as we rely rust abstraction.If we are not handling errors then they are guaranteed to be <strong>non-null values</strong>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> m<span class="op">=</span><span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span>m<span class="op">.</span>get(<span class="dv">5</span>))<span class="op">;</span><span class="co">//it returns none if the index if out of bounds otherwise returns some with elements.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">//println!("{:?}",m[5]); //This causes panic,this is a runtime error as in python.</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i<span class="op">=</span><span class="cn">Some</span>(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="cf">match</span> i<span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>some(i)<span class="op">=&gt;</span><span class="pp">println!</span>(<span class="st">"{i}"</span>)<span class="op">,</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Buffer Overflow</strong></p>
<p>Accessing elements that are not part of your data, whether it is stored on stack or heap, is a memory error. It will lead to security vulnerability since we were reading or writing memory that is not part of our data. Let’s try to access elements both from stack-allocated and heap-allocated data in rust. Notes on what is <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">stack and heap</a>, if you are curious what they are.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> stack_data <span class="op">=</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> heap_data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">//  let stack_invalid_data = stack_data[5];//Length of the array is 5 and it's zero-indexed.</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">//  println!("{}",stack_invalid_data);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> heap_invalid_data <span class="op">=</span> heap_data[<span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>heap_invalid_data)<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Rust will panic at runtime. Panicking in rust is to stop the program immediately instead of continuing further with the wrong data.</p>
<p><strong>Integer Overflow</strong></p>
<p>Integer overflow is like the buffer overflow. Integers have limits that how many values can represent depending on the bits used to represent that. There are two integer types signed and unsigned.Signed integer(negative numbers) only represent values from <span class="math inline">\(-{2}^ {(n-1)} to +2^ {(n-1)}-1\)</span> and unsigned integer represent values from <span class="math inline">\(0 to 2^n -1\)</span>.For eg, 8-bit signed integers only represent -128 to 127 values but unsigned integers represent more values than signed integers since they start from zero.Rust std libraries provide min and max values of the signed and unsigned integers. Let’s use that..</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> signed_8bit_min <span class="op">=</span> <span class="dt">i8</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> signed_8bit_max <span class="op">=</span> <span class="dt">i8</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> unsigned_64bit_min <span class="op">=</span> <span class="dt">u64</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> unsigned_64bit_max <span class="op">=</span> <span class="dt">u64</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">;</span> </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">//Only 8,6,32,64,128 bits are available for integer</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>   <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>signed_8bit_Max<span class="op">+</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Adding or subtracting one to the maximum or minimum values of any integer bits respectively causes overflow.In debug mode rust compiles with an error message.</p>
<p><strong>Use after free</strong></p>
<p>This bug happens when accessing heap or dynamically allocated data after it is freed or after released to the operating system.In c/c++ accessing values after freeing memory cause segfaults.But in rust it’s compiling time error.Why this is a bug,once heap memory is released to the operating system the memory is uninitialized or used by another program once it’s freed. So accessing the freed memory crashes the system, which causes segfaults in c/c++ when run.How rust prevents this at compile.Let’s look at the code below,</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s<span class="op">=</span><span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Rustacean"</span>)<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  call(s)<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>s)<span class="op">;</span><span class="co">//Here we access s which is freed when the call scope ends.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> call(s<span class="op">:</span><span class="dt">String</span>)<span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>push(<span class="ch">'s'</span>)<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//When the owner of heap allocated data goes out of scope,it's freed automatically.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Because of the single ownership restriction,when s is passed to fn the function call takes ownership so the function is responsible for cleaning the memory.But we try to access in the main function after it’s transferred or moved ,which is forbidden by the rust compiler. Rust won’t compile this code.</p>
<p><strong>Dangling pointer</strong></p>
<p>Returning or storing a reference to the pointer whether it is stack allocated or heap allocated is a bad idea,when they are used after freeing the memory in c/c++.This is called dangling pointers since they point at invalid memory.But rust refuses to compile at all with this bug.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Returning reference to the caller</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span>call()<span class="op">;</span><span class="co">//pointing at anywhere if rust allowed</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>m)<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> call()<span class="op">-&gt;&amp;</span><span class="ot">'static</span> <span class="dt">String</span><span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span><span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Dangling Pointer"</span>)<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>m</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//This point the m is freed</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">//storing reference and used after it's freed</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span><span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Dangling"</span>)<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s<span class="op">=&amp;</span>m<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    drop(m)<span class="op">;</span><span class="co">//explicitly freed</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//m.push_str("Fourth"); //Mutable access</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>s)<span class="op">;</span><span class="co">//Here s is not valid so rust reject this code</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Double free </strong></p>
<p>The double free error happens when heap-allocated memory calls free or delete on that memory and then we try to free that memory again eg: Calling two free() in <em>c</em> or two delete() in <em>c++</em>.Why the heck we want to free the memory twice, humans are not machine,in large code bases programmers free the memory twice by accident. It will crash the program with segfaults because when first call to free ,it will clear the data in that location then it stores the different data in that location when some program requests memory from the operating system allocator, so after calling the second free on the same data will clear the data which may cause another program to crash and using that memory to have undefined behavior.Rust prevents this by having <strong>single ownership</strong> rule i.e every variable exactly has one owner except <strong>smart pointer types</strong>.If we assign the <strong>movable type</strong> to a new variable,the new variable is the new owner and invalidates the old one.Let’s demonstrate how rust avoids double free.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span><span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Hello,Fellows"</span>)<span class="op">;</span><span class="co">//here heap allocated data initialized.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n<span class="op">=</span>m<span class="op">;</span><span class="co">//here m is moved to n,now m is uninitialized.exactly one drop is called when the owner goes out of scope.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}-{}"</span><span class="op">,</span>m<span class="op">,</span>n)<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//here only n will freed implicitly by the compiler ,not both m and n.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span><span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    drop(m)<span class="op">;</span><span class="co">//explicitly freed once</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    drop(m)<span class="op">;</span><span class="co">//try to clean the memory twice ,but rust complies with 'Use of moved value'</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><em>Drop</em> is the rust equivalent of free, delete in c++. The rust compiler inserts the drop automatically when the owner goes out of scope.(Scope -a region where memory accesses are valid). This bug does not happen in GCed language where the GC only cleans the memory when there is no reference to that object but it’s not predictable.</p>
<p><strong>Memory leak</strong>:</p>
<p>In c/c++ forgetting to release the memory to the os once we have done with it resulted in memory leaks. Manual memory management is efficient because we can use larger memory and then release the memory by calling delete at <strong>predictable</strong> point in code so that we can use memory for the further task without exhausting the system memory.But forgetting to that prevents other programs to use the resources.Look at the below code ,looks like the file is not closed and not handling failure…</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::io::prelude::</span><span class="op">*;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>create_file()<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> create_file()<span class="op">-&gt;</span><span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> file<span class="op">=</span><span class="pp">File::</span>create(<span class="st">"text.txt"</span>)<span class="op">?;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>write(<span class="st">b"There is no need to close file explicitly as there is no close method </span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="st">The file close implicitly when the scope ends"</span>)<span class="op">?;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There are no leaks here. Rust uses scoped management for releasing memory and other resources when they are goes out of scope. This is how rust manages sockets,locks,files.Garabge collector only help you with memory errors not resources.In python <strong>with</strong> statement used to release the resources when the scope ends,other wise it’s still uses that file until the program terminates. Other languages provide similar mechanisms to handle resources other than memories.The <strong>?</strong> operator is an ergonomic way to handle failure in rust,on success it returns nothing i.e () ,on failure it returns early with error without further processing.</p>
<p><strong>Iterator Invalidation</strong></p>
<p>Create a data structure, pass them to the function as two parameters. The same data structure tries to add elements to it at each loop sate but it’s infinitely run because the loop counts is increased each time a loop enters the body. But it’s not the problem though, it is used after freed memory whenever the vector doesn’t have space to store it , it will move to a new place then a shared pointer reads invalid memory if we are allowed this operation it’s writing data to other data structures.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">mut</span> v<span class="op">:</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> v1<span class="op">:</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">23</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a> call( <span class="op">&amp;</span><span class="kw">mut</span> v<span class="op">,</span> <span class="op">&amp;</span>v1)<span class="op">;</span><span class="co">//passing mutable and immutable references</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a> <span class="co">//call( &amp;mut v,&amp;v);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a> <span class="pp">println!</span>(<span class="st">" {:?} "</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> call(s<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;,</span>s1<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span>)<span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> s1<span class="op">.</span>iter() <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push(<span class="op">*</span>i)<span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The above code tries to add elements of v1 to v and compiles successfully. But what if we pass the same vector to the function? Try uncommenting the second function call <strong>call()</strong>, then look at what the compiler says.It says,</p>
<blockquote class="blockquote">
<p>cannot borrow <code>v</code> as immutable because it is also borrowed as mutable.</p>
</blockquote>
<p>What is remarkable is that just looking at the function signature rust would able to detect this. Compile the above code by removing the for loop inside a function body. Rust has a restriction that either <strong>One mutable reference(write) to the object or Multiple immutable reference(read)</strong> at a time.</p>
<p>Why this is a bug? There is two things that happen if a program is allowed, either the loop run infinitely because each time the for loop runs it increases the length of the vector which is infinite since pushing elements to the same vector increases the length, or crashes the program , pushing more elements to the vector increase the capacity which in turns allocate more memory from operating system then move the data to a new location this is same as use after free. Run this python code in your editor or online python interpreter</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>data<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> data: <span class="co">#reads the data i.e iterating </span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    data.append(i) <span class="co">#after this the list length is increased thus for loop iteration.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Concurrency Bug</strong>:</p>
<p>Concurrency bugs are related to memory bugs where without synchronization the memory access is incorrect because of a race condition where multiple threads are accessing the same memory. Writing concurrency programs is not an easy task,only experienced programmers can write still buggy though. But functional programming like haskell,erlang,elixir or imperative like go provide a better abstraction for writing concurrency without much experience in concurrency programs. But they are still misused if we are not careful.</p>
<p>Rust forces you to use synchronization for shared memory before sharing between threads. Because of the restriction on <strong>Aliasing and Mutatation </strong> we can write low level concurrency as in c/c++ but with much more safety and guarantee.In below code, there is no way to access the data inside the mutex without locking it first which gives exclusive access. Note that this is a single-threaded code.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Mutex<span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> i<span class="op">=</span><span class="pp">Mutex::</span>new(<span class="dv">45</span>)<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">*</span>i<span class="op">+=</span><span class="dv">10</span><span class="op">;</span> <span class="co">//type `Mutex&lt;{integer}&gt;` cannot be dereferenced,We are forced to use lock on mutex</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> l<span class="op">=</span>i<span class="op">.</span>lock()<span class="op">;</span><span class="co">//Even though we lock the data inside of mutex,we still can't acess the data unless    handling the error since the return type is Result which must be hadled via pattern matching or call unwrap to get the value inside</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//let mut l=i.lock().unwrap();//without mut we can't mutate the data </span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>l<span class="op">+=</span><span class="dv">10</span><span class="op">;</span><span class="co">//</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span>l)<span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>But where do we unlock the mutex? We don’t, when the scope ends the lock is unlocked automatically. The same procedure is to help to automatically close the file above.Just in three lines of code ,we can see that how rust prevent you to compile the code without using APIs properly.Rust supports more than shared memory model concurrency.</p>
<p>But Gc Language doesn’t save you from concurrency bugs, other resources like files, sockets,databases without putting a restriction on the design of the language like immutable data structure, lifetime of objects or scoped objects. But they are not forced by the language runtime thus it’s easy to make mistakes.</p>
<p>Being memory safety doesn’t mean being immune to security-related problems. What about the other 30 percent of vulnerability in Microsoft and chromium, which must be mitigated by source code analysis and extensive testing?</p>
<p>Just using memory-safe languages makes certain memory-related bugs not existed in the first place. But when writing performance-critical software, the choices include c/c++ but they are not safe by default. Now we have rust that is safe and runs on bare metal as it lacks a runtime.</p>
<p>Android chose rust to write new native code and kotlin, java at a high level.</p>
<p>Apple creates swift as memory safe and modern with a deterministic approach to memory management.</p>
<p><a href="https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html?m=1">Rust in Android</a>.</p>
<p><a href="https://security.googleblog.com/2023/01/supporting-use-of-rust-in-chromium.html?m=1">Rust in chromium</a></p>
<p><a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Fearless concurrency with rust</a>.</p>
<p><a href="https://msrc-blog.microsoft.com/2019/07/18/we-need-a-safer-systems-programming-language/">Microsoft chooses Rust for writing new code</a>.</p>
<p><a href="https://alexgaynor.net/2019/aug/12/introduction-to-memory-unsafety-for-vps-of-engineering/">Why Memory safety is important</a></p>
<p><a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">Seriousness of NULL</a></p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL50-CPP.+Do+not+define+a+C-style+variadic+function">C++ Rules to follow in order to doesn’t cause undefined behavior at runtime</a>. In case of rust,the compiler has your back i.e bugs are caught by the compiler.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>