<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sanjeevi">
<meta name="dcterms.date" content="2023-01-02">

<title>Home - Memory safety, what it is?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Home - Memory safety, what it is?">
<meta property="og:description" content="A snippets from PROSSIMO">
<meta property="og:site-name" content="Home">
<meta name="twitter:title" content="Home - Memory safety, what it is?">
<meta name="twitter:description" content="A snippets from PROSSIMO">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Home</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://twitter.com/PySanjeevi/"><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text">Twitter</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.linkedin.com/in/sanjeevi-%E0%AE%9A%E0%AE%9E%E0%AF%8D%E0%AE%9A%E0%AF%80%E0%AE%B5%E0%AE%BF-01a7b813b/"><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text">LinkedIn</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/Sanjuvi/"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text">Github</span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Memory safety, what it is?</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Code</div>
                <div class="quarto-category">Theory</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Sanjeevi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 2, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>A snippets from <a href="https://www.memorysafety.org/docs/memory-safety/">PROSSIMO</a></p>
<blockquote class="blockquote">
<p>Memory safety is a property of some programming languages that prevents programmers from introducing certain types of bugs related to how memory is used. Since memory safety bugs are often security issues, memory safe languages are more secure than languages that are not memory safe.</p>
</blockquote>
<p>Memory unsafe languages like c/c++</p>
<p>Raw pointers are root cause of the memory safety violation since allocating heap data involves pointers.Raw pointer as the name suggest ,carry no information other than pointing to the dynamically allocated data.So ownership,lifetime of a pointer not controlled by compiler.They are too unsrestricted,this is useful for interacting with hardware since harware inherently unsafe only 0s and 1s nothing more,that’s why rust has <strong>Unsafe</strong> escape hatch to break the compiler restriction and they are insanely fast as fast as the hardware allowed.</p>
<p>Advances in type theories helps to mitigate memory related errors statically by the type systems.</p>
<p>Typed Pointer -Pointer only contain values that are allowed by types(i32-f32-4bytes,i64-f64-8bytes).For eg,in c if you declared int pointer and using the value without giving intial values contains random data.That random data contains data only values that are representable by int type,not any type ,but that’s undefinde behaviour contains any random integer value.</p>
<p>Smart Pointers-Resource Acquistion Is Initialization(RAII).In case of c++,samrt pointers responsible for cleaning the memory without programmer intervention.No GC is required ,it’s deterministic.</p>
<p>Memory allocations or pointers are ergonomics to use in rust than in c/c++ and also memory safe.There is no explicit equivalent new/delete or malloc/free keyword to allocate memory on the heap.Allocation and deallocation of memories in rust is automated by the compiler at compile time.Rust provide abstraction for pointers. .Some rust basic pointers, - <strong>Owned pointers</strong> contains 1) pointer to the heap allocated data,2) length of currently stored items, 3) capacity,how much memory is allocated from the Operating system.</p>
<ul>
<li><strong>Slice pointers</strong> are fat pointers contains 1)pointer to the heap allocated data but not owned,2)length the of items it’s borrowed currently.</li>
</ul>
<p>Memory safe languages: Python,rupy,perl,java,scala,go,kotlin,swift,rust,haskell,js.,Ada,D,pony,zig.Autually any programming language other than c,c++,assembly(Typeless)..</p>
<p>We shoud thankful for these high level programming language for building prototype with sort of amount time ,without hasing memory bugs.</p>
<p>Memory Unsafe Language: c &amp; c++ -what ? Thease are the language that underpin every thing we use from os to database,embedded system,drivers. But why don’t we use safe language to do ? Control-Access the hardware,low level. predictability(Manual Memory management). Binary(Deployment is easy,Size is low as in binary,Fast startup since there is no runtime to be initialized before running program)</p>
<p><strong>Memory Related Bugs</strong></p>
<ul>
<li>Using uninitialized variable</li>
<li>Buffer over-read and over-write</li>
<li>Integer Overflow</li>
<li>Use after free</li>
<li>Double free</li>
<li>Memory leak</li>
</ul>
<p>The above errors are mitigated by memory safe langauges which uses <strong>Garbage Collector</strong> though not all.What’s so unique about rust is that these errors are ruled out at compile time except overflow which determined at runtime.This is important distinction that makes rust different from dynamic programming language and c/c++.Now look at how rust prevent this.Don’t worry about the rust syntax now.</p>
<p><strong>Buffer Overflow</strong></p>
<p>Accessing elements that are not part of your data ,whether it is stored on stack or heap,is an memory error.It will crash the system since we were reading or writing memory that are invalid inputs and it leads to security vulnerability.Let’s try to access elements both from stack allocated and heap allocated data in rust.Notes on what is <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">stack and heap</a>,if you are curious what they are.Use this <a href="https://play.rust-lang.org/">link</a> to execute the code yourself in browser.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> stack_data <span class="op">=</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> heap_data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">//  let stack_invalid_data = stack_data[5];//Length of the array is 5 and it's zero indexed.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">//  println!("{}",stack_invalid_data);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> heap_invalid_data <span class="op">=</span> heap_data[<span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>heap_invalid_data)<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Rust will panic at runtime.Panicking in rust is to the stop the program immediately instead of continue with the wrong inputs.</p>
<p><strong>Integer Overflow</strong></p>
<p>Integer overflow is like buffer overflow.Integers have limits that how much values can represent depending on the bits used to represent that.There are two intger type signed and unsigned.Signed integer(negative numbers) only represent values from <span class="math inline">\(-{2}^ {(n-1)} to +2^ {(n-1)}-1\)</span> and unsigned integer represent values from <span class="math inline">\(0 to 2^n -1\)</span>.For eg,8bit signed intger only represent -128 to 127 values but unsigned inetger represent more values than signed integer since they start from zero.Rust std libraries provides min and max values of the signed and unsigned integer.Let’s use that..</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> signed_8bit_min <span class="op">=</span> <span class="dt">i8</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> signed_8bit_max <span class="op">=</span> <span class="dt">i8</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> unsigned_64bit_min <span class="op">=</span> <span class="dt">u64</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> unsigned_64bit_max <span class="op">=</span> <span class="dt">u64</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">;</span> </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">//Only 8,6,32,64,128 bits are available for integer</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>   <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>signed_8bit_Max<span class="op">+</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Adding or subtracting one to the maximum or minimum values of any integer bits respectively causes overflow.In debug mode rust compile with error message.Floating points are different ,they represent infinites values.IEEE standard provides way to handle that.</p>
<p><strong>Use after free</strong></p>
<p>This bug is happen when accessing heap or dynamically allocated data after it is freed or after released to operating system.In c/c++ accessing values after freeing memory causes runtime error.But in rust it’s compile time error.Why this is a bug,once heap memory is released to the operating system the memory is uninitialized or used by other program once it’s freed.So accessing the freed memory crash the system,this causes segfaults in c/c++ when ran.How rust prevent this at compile.Let’s look at the code below,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s<span class="op">=</span><span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Rustacean"</span>)<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  call(s)<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>s)<span class="op">;</span><span class="co">//Here we accessing s which is freed when call scope ends.</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> call(s<span class="op">:</span><span class="dt">String</span>)<span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>push(<span class="ch">'s'</span>)<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//When the owner of heap allocated data goes out of scope,it's freed automatically.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Rust won’t compile this code.Without using garbage collector,rust can prevent this at compile time.</p>
<p><strong>Dangling pointer</strong></p>
<p>Returning or storing reference to the pointer is a bad idea,when they are used after freeing the memory in c/c++.This is called dangling pointers since they pointing at invalidate memory.But rust refuse to compile at all with this bug.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Returning reference to the caller</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span>call()<span class="op">;</span><span class="co">//pointing at anywhere</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>m)<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> call()<span class="op">-&gt;&amp;</span><span class="ot">'static</span> <span class="dt">String</span><span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span><span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Dangling Pointer"</span>)<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>m</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//This point the m is freed</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">//storing reference and used after it's freed</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span><span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Dangling"</span>)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s<span class="op">=&amp;</span>m<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    drop(m)<span class="op">;</span><span class="co">//explicitly freed</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>s)<span class="op">;</span><span class="co">//it's not valid here so rust reject this code</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Double free </strong></p>
<p>Once freed the memory ,we again free that memory twice eg:Calling 2 free in <em>c</em> or 2 Delete in <em>c++</em>.Why the heck we want to free the memory twice,humans are not machine in large code bases programmers free the memory twice by accident. It will crash the program because when first call to free ,it will clear the data in that location then it is store the different data in that location when some program requesting memory from operating system allocator,so after calling second free on the same data will clear the data which may cause other program to crash and using that memory have undefined behaviour.Rust prevent this by having <strong>single ownership</strong> rule i.e every variable exactly have one owner except <strong>smart pointer types</strong>.If we assign the <strong>movable type</strong> to new variable ,the new varible is the new owner and invalidate the old one.Let’s demonstrate how rust avoid double free and accessing the old variable.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">=</span><span class="dt">String</span><span class="pp">::</span>from(<span class="st">"Hello,Fellows"</span>)<span class="op">;</span><span class="co">//here heap allocated data initialized.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n<span class="op">=</span>m<span class="op">;</span><span class="co">//here m is moved to n,now m is uninitialized.exactly one drop is called when the owner goes out of scope.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}-{}"</span><span class="op">,</span>m<span class="op">,</span>n)<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="co">//here only n will freed not both m and n.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><em>Drop</em> is quivalent of free,delete in rust.The rust compiler insert the drop automatically when the owner goes out of scope.(Scope -a region where it’s valid).This bug not introduced in GCed laguage where GC only clean the memory when there is no reference to that object but it’s not predictable.</p>
<p><strong>Memory leak</strong>:</p>
<p>In c/c++ forgot to release the memory to the os once we done with it using free or delete result in crash ,memory leaks.Continuous resource using eg:Forgot to close Sockets , Files , Database , Lock leads to undefined behaviour.It will consume the memory for longer than neccessary which prevents other porgram to use the resources.Rust uses scoped management for releasing memory and other resources when they are goes out of scope.Garabge collector only help you with memory errors not resources.In python <strong>with</strong> statement used to release the resources when scope ends,other wise it’s still uses that file until terminate the program.Other languages provide similar mechanism to handle resources.</p>
<p><strong>Use of Uninitialized Variable</strong></p>
<p>If you declare a varibale it’s uninitialized if initial value not given by the programmer.When using that value it will crash or create backdoor for hacker to take control over our machine.GCed language use control flow analyse to prevent using uninitialized variables.Rust do the same.Uninitialized pointers are called wild pointers.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m<span class="op">:</span><span class="dt">i32</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">"{}"</span><span class="op">,</span>m)<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You get a compile time error.The type annotation is needed here since without initializing variable with value,rust won’t infer the type of the variable.</p>
<p><strong>Iterator Invalidation</strong></p>
<p>Create a data structure.pass them to the function as two perameters.the same data structure try to add elements to it at each loop sate but it’s infinitely run beacause the loop counts is increased each time a loop enters the body.But it’s not the problem though,it is using after freed memory whenever the vector doesn’t have space to store it ,it will move to new place then shared pointer reading invalid memory if we are allowed this operation it’s write data to other data structure.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main()<span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">mut</span> v<span class="op">:</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> v1<span class="op">:</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span><span class="dv">23</span><span class="op">,</span><span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a> call( <span class="op">&amp;</span><span class="kw">mut</span> v<span class="op">,</span> <span class="op">&amp;</span>v1)<span class="op">;</span><span class="co">//passing mutable and immutable references</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a> <span class="co">//call( &amp;mut v,&amp;v);</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a> <span class="pp">println!</span>(<span class="st">" {:?} "</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> call(s<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;,</span>s1<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span>)<span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> s1<span class="op">.</span>iter() <span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push(<span class="op">*</span>i)<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The above code try to add elements of v1 to v and compiles successfully.But what if we pass the same vector to the function.Try uncommenting the second function call <strong>call()</strong>,then look at what compiler says.It says,</p>
<blockquote class="blockquote">
<p>cannot borrow <code>v</code> as immutable because it is also borrowed as mutable.</p>
</blockquote>
<p>What is remarkable is that just looking at the funcion signature rust would able to detect this.Compile the above code by removing the for loop inside a function body.Rust has a restriction that either <strong>One mutable reference(write) to the object or Multiple immutable reference(read)</strong> at a time.</p>
<p>Why this is a bug.There is two things happen either the loop run infinitely because each time the for loop runs it increase the length of the vector which is infinite since pushing elements to the same vector increase the length or crash the program ,pushing more elements to the vector increase the capacity which in turns allocate more memory from operting system then move the data to new location this is same as use after free. In c/c++ it will crash the program,dynamic programming language issue a runtime error.Run this python code in your editor or online python interpreter</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>data<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> data: <span class="co">#reads the data i.e iterating </span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    data.append(i) <span class="co">#after this the list length is increased thus for loop iteration.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Concurrency Bug: Data Inconsistent-Race Condition,Data Races,DeadLock,</p>
<p>time of check to time of use(TOCTTOU)-A race condition bug.Without <strong>atomic</strong> synchronization,it deliberately fail.Atomic sync ensure that some operation performed before other operation take that result.For example without login,we can’t show the details.</p>
<p>But Gc Language doesn’t save you from concurrency bugs,other memory resources like files,sockets,databases without putting restriction on the design of the language like immutable data structure,lifetime of an objects or scoped objects,synchronization.But they are not forced by the language runtime thus it’s easy to make mistake as long as we rely on abstracion provided by the language.wait for the festure blog posts about rust ownership,borrowing,lifetime,traits to understand the concurrency paradigm.</p>
<p>Rust only save you from memory bugs,but not security which is still captured by testing,code reviews.</p>
<p>Just using memory safe languages makes certain memory related bugs not existed in the first place.But when writing performance critical software,the choices are include c/c++ but they are not safe.Now we have rust that is safe and runs on bare metal because of lack of garbage collector.</p>
<p>There is reason why android developers wite android apps using java which provide memory safty through GC.They are just abstraction(API) provided by the Andoid kernel wwhich itself written in c/c++ in that way we won’t introduce any above mentioned memory bugs as long as Java Native Interface are sound.</p>
<p>Apple also introduce new langauge to avoid the creating memory bug in the first place.Swift is memory safe language using deterministic approach to manage memory.</p>
<p><a href="https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html?m=1">Memory Safe Languages in Android 13</a>.</p>
<p><a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Fearless concurrency with rust</a>.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>