<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Home</title>
<link>https://sanjuvi.github.io/Blog/index.html</link>
<atom:link href="https://sanjuvi.github.io/Blog/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.2.280</generator>
<lastBuildDate>Sun, 26 Feb 2023 08:00:00 GMT</lastBuildDate>
<item>
  <title>Ownership and Borrowing in Rust</title>
  <dc:creator>Sanjeevi </dc:creator>
  <link>https://sanjuvi.github.io/Blog/posts/Ownership-and-borrowing-in-rust/index.html</link>
  <description><![CDATA[ 




<p>Before we can talk about this weird concept in rust, why do we have them in the first place? Most modern languages solve problems with existing languages like java, JavaScript, objective c, and python. Before reading this blog post, I want you to read my previous blog post about <a href="https://sanjuvi%20github.io/Blog/posts/Zero-cost-abstraction/">zero cost abstraction</a> and <a href="https://sanjuvi.github.io/Blog/posts%20Memory-Unsafety/">memory safety</a> or some knowledge of why c/c++ still dominates the world even modern language emerges.</p>
<p>Ownership is a restriction on rust to prevent temporal memory error (like Use after Free, dangling pointer), double free by statically i.e at <strong>compile time</strong> without using any runtime when the program running. This is an important characteristic for many reasons. As we will see, how ownership aid in ergonomics use of language features that no other mainstream language could think of.</p>
<p>Modern c++ introduces <strong>RAII-Resource Allocation Is Initialization</strong> i.e the objects(files, resources) or raw pointers encapsulated inside class objects. When the object goes out of scope, its destructor is called automatically. This is deterministic, not employing a garbage collector. Even though modern c++ encourages you to use it,</p>
<ul>
<li><ol type="1">
<li>RAII-based smart pointers for managing resources instead of using raw pointers.</li>
</ol></li>
<li><ol start="2" type="1">
<li>STL(Standard Template Libraries) abstraction to get rid of low-level details in loops, and programming.</li>
</ol></li>
<li><ol start="3" type="1">
<li>Closure to capture the enclosing environment. But rust closure is way more capable and safe than c++ closure.</li>
</ol></li>
</ul>
<p>These APIs are still possible to misuse. Read this blog post about <a href="https://alexgaynor.net/2019/apr/21/modern-c++-wont-save-us/">Why modern c++ still causes you a memory error</a>. I’m not here to blame c++ in favor of rust. I’m just saying that for people like me who came from dynamic programming languages like python,<strong>rust compiler is more backup than a c++ compiler as the errors contain rich error information and also suggesting to fix it this felt so amazing </strong> when writing system level programming for the first time in their life. But I definitely admit that rust is not a beginner-friendly language when starting but the pay off definitely worth it when considering all things around us surrounded by software where safety is <strong>First Class</strong> important.</p>
<p>In rust, every variable has a unique owner except <strong>Smart pointers</strong>. That is, the owner is responsible for cleaning up the memory once it’s done with it and also ensures that no other references to that object are when cleaning up that memory, a task that the borrow checker checks using the <strong>lifetime</strong>.</p>
<p>Moveable types are moved to a new variable when assigned where as copyable types are copied when assigned to a new variable. How does rust know whether the type is Copy or Move? This is where traits come in. The trait is like Haskell’s type classes, swift’s protocols, or java,c# interfaces. Here we only consider two traits that are in the std library copy and drop trait. If the type implements the Copy trait, then when assigned to a new variable it’s <strong>cloned implicitly</strong> i.e deep copy. So that we can use the variable after it’s assigned and the borrow checker won’t complain.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb1-1"><span class="co" style="color: #5E5E5E;">//prevent the compiler warning about unused variables.</span></span>
<span id="cb1-2"><span class="at" style="color: #657422;">#[</span>allow<span class="at" style="color: #657422;">(</span>unused_variables<span class="at" style="color: #657422;">)]</span> </span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb1-4"></span>
<span id="cb1-5"> <span class="kw" style="color: #003B4F;">let</span> int<span class="op" style="color: #5E5E5E;">=</span><span class="dv" style="color: #AD0000;">34</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-6"> <span class="kw" style="color: #003B4F;">let</span> int_copy <span class="op" style="color: #5E5E5E;">=</span>int<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-7"></span>
<span id="cb1-8"> <span class="kw" style="color: #003B4F;">let</span> boolean<span class="op" style="color: #5E5E5E;">=</span><span class="cn" style="color: #8f5902;">true</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-9"> <span class="kw" style="color: #003B4F;">let</span> boolean_copy<span class="op" style="color: #5E5E5E;">=</span>boolean<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-10">  </span>
<span id="cb1-11"> <span class="kw" style="color: #003B4F;">let</span> float<span class="op" style="color: #5E5E5E;">=</span><span class="dv" style="color: #AD0000;">2.1</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-12"> <span class="kw" style="color: #003B4F;">let</span> float_copy<span class="op" style="color: #5E5E5E;">=</span>float<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-13"></span>
<span id="cb1-14"> <span class="kw" style="color: #003B4F;">let</span> character <span class="op" style="color: #5E5E5E;">=</span><span class="ch" style="color: #20794D;">'M'</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-15"> <span class="kw" style="color: #003B4F;">let</span> character_copy<span class="op" style="color: #5E5E5E;">=</span>character<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-16"> </span>
<span id="cb1-17"> <span class="kw" style="color: #003B4F;">let</span> strr<span class="op" style="color: #5E5E5E;">=</span><span class="st" style="color: #20794D;">"Sanjeevi"</span><span class="op" style="color: #5E5E5E;">;</span>  </span>
<span id="cb1-18"> <span class="kw" style="color: #003B4F;">let</span> strr_copy <span class="op" style="color: #5E5E5E;">=</span>strr<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-19"></span>
<span id="cb1-20"> <span class="kw" style="color: #003B4F;">let</span> array<span class="op" style="color: #5E5E5E;">=</span>[<span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">34</span>]<span class="op" style="color: #5E5E5E;">;</span> </span>
<span id="cb1-21"> <span class="kw" style="color: #003B4F;">let</span> array_copy <span class="op" style="color: #5E5E5E;">=</span>array<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-22"></span>
<span id="cb1-23"><span class="co" style="color: #5E5E5E;">//only true when all the types inside the tuple themselves are copy types</span></span>
<span id="cb1-24"> <span class="kw" style="color: #003B4F;">let</span> tuple<span class="op" style="color: #5E5E5E;">=</span>(int<span class="op" style="color: #5E5E5E;">,</span>boolean<span class="op" style="color: #5E5E5E;">,</span>float<span class="op" style="color: #5E5E5E;">,</span>character)<span class="op" style="color: #5E5E5E;">;</span> </span>
<span id="cb1-25"> <span class="kw" style="color: #003B4F;">let</span> tuple_copy<span class="op" style="color: #5E5E5E;">=</span>tuple<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-26"></span>
<span id="cb1-27"><span class="co" style="color: #5E5E5E;">//no error since they are copy types.</span></span>
<span id="cb1-28"> <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{int} {float} </span><span class="sc" style="color: #5E5E5E;">\n</span><span class="st" style="color: #20794D;">{boolean} {character} {strr} </span></span>
<span id="cb1-29"><span class="st" style="color: #20794D;">        </span><span class="sc" style="color: #5E5E5E;">\n</span><span class="st" style="color: #20794D;">{array:?} {tuple:?}"</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-30"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>But when the type own resources or calling drop when goes out of scope, then it’s <strong>moved implicitly</strong>, that’s why when trying to use the old one results in compile error that <strong>use of moved value</strong>.<strong>Rust way of doing implicit and explicit</strong> doesn’t cost anything since deep copying the stack allocated is cheap but heap allocated not. So we have to explicitly about deep copying the heap data by cloning them. <strong>Custom types</strong> are moved implicitly. Here move means the stack pointing to the heap-allocated data was moved not the heap itself i.e the actual data, so here moves are efficient since we only move the stack(ptr,len, capacity) not the actual data residing in Heap. Why this is efficient because</p>
<ul>
<li><strong>1)ptr</strong>-pointer to the heap</li>
<li><strong>2) len</strong>-length of currently allocated elements,</li>
<li><strong>3) Capacity</strong>-size of the allocation is stored in the stack.</li>
</ul>
<p>These are the metadata to provide an abstraction to correctly allocate and deallocate the data without the manual involvement of memory allocation as in c/c++.</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb2-1"><span class="at" style="color: #657422;">#[</span>allow<span class="at" style="color: #657422;">(</span>unused_variables<span class="at" style="color: #657422;">)]</span></span>
<span id="cb2-2"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb2-3"> </span>
<span id="cb2-4"> <span class="kw" style="color: #003B4F;">let</span> vector <span class="op" style="color: #5E5E5E;">=</span> <span class="pp" style="color: #AD0000;">vec!</span>[<span class="st" style="color: #20794D;">"Same type of heap allocated data"</span><span class="op" style="color: #5E5E5E;">,</span><span class="st" style="color: #20794D;">"Hi ,rustaceans"</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-5"> <span class="kw" style="color: #003B4F;">let</span> vector_move <span class="op" style="color: #5E5E5E;">=</span> vector<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-6"></span>
<span id="cb2-7"><span class="kw" style="color: #003B4F;">let</span> string <span class="op" style="color: #5E5E5E;">=</span> <span class="dt" style="color: #AD0000;">String</span><span class="pp" style="color: #AD0000;">::</span>from(<span class="st" style="color: #20794D;">"Mutable heap allocated string type"</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-8"><span class="kw" style="color: #003B4F;">let</span> string_move <span class="op" style="color: #5E5E5E;">=</span> string<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-9"> </span>
<span id="cb2-10"> <span class="kw" style="color: #003B4F;">let</span> vector_of_integers <span class="op" style="color: #5E5E5E;">=</span> <span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">25</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2023</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-11"> <span class="co" style="color: #5E5E5E;">//we have to explicit</span></span>
<span id="cb2-12"> <span class="kw" style="color: #003B4F;">let</span> clone_of_vector_of_integers <span class="op" style="color: #5E5E5E;">=</span> vector_of_integers<span class="op" style="color: #5E5E5E;">.</span>clone()<span class="op" style="color: #5E5E5E;">;</span> </span>
<span id="cb2-13"> </span>
<span id="cb2-14"> <span class="co" style="color: #5E5E5E;">//only true when all the types inside the tuple themselves are copy types</span></span>
<span id="cb2-15"><span class="kw" style="color: #003B4F;">let</span> tuple<span class="op" style="color: #5E5E5E;">=</span>(vector<span class="op" style="color: #5E5E5E;">,</span>vector_of_integers<span class="op" style="color: #5E5E5E;">,</span>string)<span class="op" style="color: #5E5E5E;">;</span> </span>
<span id="cb2-16"><span class="kw" style="color: #003B4F;">let</span> tuple_move<span class="op" style="color: #5E5E5E;">=</span>tuple<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-17"></span>
<span id="cb2-18"><span class="co" style="color: #5E5E5E;">//no error since they are copy types.</span></span>
<span id="cb2-19"><span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{vector:?} </span><span class="sc" style="color: #5E5E5E;">\n</span><span class="st" style="color: #20794D;">{string:?}</span><span class="sc" style="color: #5E5E5E;">\n</span><span class="st" style="color: #20794D;">{vector_of_integers:?}</span><span class="sc" style="color: #5E5E5E;">\n</span><span class="st" style="color: #20794D;"> </span></span>
<span id="cb2-20"><span class="st" style="color: #20794D;">         {clone_of_vector_of_integers:?} </span><span class="sc" style="color: #5E5E5E;">\n</span><span class="st" style="color: #20794D;">{tuple:?}"</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-21"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>But ownership is more restrictive than it has to be. Can we use references like c++ references but safely? Absolutely we can. Enter borrowing, instead of taking ownership we can temporarily borrow it. There is a distinction here. The borrow is either immutable <strong><em>or</em></strong> mutable depending on the signature. Like move types, mutable borrow moves the mutable borrows if assigned to new variables since they are <strong>unique</strong>.Instead of <strong>cleaning the memory</strong> when the scope ends,<strong>we end the borrow</strong> since we don’t own the data. Like copy types, immutable borrow copy the borrows, because multiple immutable shared, borrows are permitted as long as there is no overlapping mutable borrow sounds like concurrency right? Yet this same restriction allows rust to prevent <strong>data race at compile time</strong>, yes,<strong>at compile time</strong>.</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb3-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb3-2"> </span>
<span id="cb3-3"> <span class="kw" style="color: #003B4F;">let</span> <span class="kw" style="color: #003B4F;">mut</span> data <span class="op" style="color: #5E5E5E;">=</span> <span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">3</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">4</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-4"><span class="co" style="color: #5E5E5E;">//Multiple immutable references or aliases are permitted in the same scope</span></span>
<span id="cb3-5"> <span class="kw" style="color: #003B4F;">let</span> immutable_reference_1 <span class="op" style="color: #5E5E5E;">=</span> <span class="op" style="color: #5E5E5E;">&amp;</span>data<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//reference to whole collection</span></span>
<span id="cb3-6"> <span class="kw" style="color: #003B4F;">let</span> immutable_reference_1_copy <span class="op" style="color: #5E5E5E;">=</span> immutable_reference_1<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-7"> <span class="kw" style="color: #003B4F;">let</span> immutable_reference_2 <span class="op" style="color: #5E5E5E;">=&amp;</span>data[<span class="dv" style="color: #AD0000;">0</span>]<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//reference to first element</span></span>
<span id="cb3-8"> <span class="co" style="color: #5E5E5E;">//we can't mutate data behind immutable references just like variables</span></span>
<span id="cb3-9"><span class="co" style="color: #5E5E5E;">// *immutable_reference_2=23; immutable by default</span></span>
<span id="cb3-10"><span class="co" style="color: #5E5E5E;">//so do the references.</span></span>
<span id="cb3-11">  <span class="kw" style="color: #003B4F;">let</span> mutable_reference <span class="op" style="color: #5E5E5E;">=&amp;</span><span class="kw" style="color: #003B4F;">mut</span> data<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-12"></span>
<span id="cb3-13"><span class="co" style="color: #5E5E5E;">//the value is moved here since they are unique i.e not disable</span></span>
<span id="cb3-14">  <span class="kw" style="color: #003B4F;">let</span> mutable_reference_move<span class="op" style="color: #5E5E5E;">=</span>mutable_reference<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-15">  <span class="co" style="color: #5E5E5E;">//mutable_reference doesn't exist at this point</span></span>
<span id="cb3-16">  <span class="co" style="color: #5E5E5E;">// *mutable_reference=vec![5,6,7,8,9,10];</span></span>
<span id="cb3-17"></span>
<span id="cb3-18">  <span class="co" style="color: #5E5E5E;">//here we derefencing using * operator just like c++</span></span>
<span id="cb3-19">   <span class="op" style="color: #5E5E5E;">*</span>mutable_reference_move<span class="op" style="color: #5E5E5E;">=</span><span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">5</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">6</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">7</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">8</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">9</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">10</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-20">   <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{:?}"</span><span class="op" style="color: #5E5E5E;">,</span>data)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-21"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>Try uncommenting the lines and see what your friend(the compiler) tells you about that.</p>
<p>Ownership and borrowing are crucial to understanding the rest of the rust language features. They are applied to local variables, function calls, methods, threads, data structures, and closures.</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb4-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb4-2"></span>
<span id="cb4-3">  <span class="kw" style="color: #003B4F;">let</span> <span class="kw" style="color: #003B4F;">mut</span> vector<span class="op" style="color: #5E5E5E;">:</span><span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">i32</span><span class="op" style="color: #5E5E5E;">&gt;</span> <span class="op" style="color: #5E5E5E;">=</span><span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">999</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">666</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-4">  <span class="co" style="color: #5E5E5E;">//the order of the calling function is important.We can alternate b/w </span></span>
<span id="cb4-5">  <span class="co" style="color: #5E5E5E;">//immutable and mutable one since they are not</span></span>
<span id="cb4-6">  <span class="co" style="color: #5E5E5E;">//overlapping each other and we can call as many times as we want as long as the vector is not moved</span></span>
<span id="cb4-7">  mutable_borrowing(<span class="op" style="color: #5E5E5E;">&amp;</span><span class="kw" style="color: #003B4F;">mut</span> vector)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-8">  immutable_borrowing(<span class="op" style="color: #5E5E5E;">&amp;</span>vector)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-9"></span>
<span id="cb4-10">  <span class="co" style="color: #5E5E5E;">//Here the vector is moved and the new owner is new_owner.</span></span>
<span id="cb4-11">  <span class="kw" style="color: #003B4F;">let</span> new_owner<span class="op" style="color: #5E5E5E;">=</span>takes_and_return(vector)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-12">  <span class="co" style="color: #5E5E5E;">//we can't call any function that accepts the vector variable</span></span>
<span id="cb4-13">  moves_and_takes_ownership(new_owner)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-14">   <span class="co" style="color: #5E5E5E;">//immutable_borrowing(&amp;vector);</span></span>
<span id="cb4-15">  <span class="co" style="color: #5E5E5E;">//mutable_borrowing(&amp;mut vector);</span></span>
<span id="cb4-16">    </span>
<span id="cb4-17"><span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb4-18"><span class="kw" style="color: #003B4F;">fn</span> immutable_borrowing(a<span class="op" style="color: #5E5E5E;">:&amp;</span><span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">i32</span><span class="op" style="color: #5E5E5E;">&gt;</span>)<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb4-19">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{:?}"</span><span class="op" style="color: #5E5E5E;">,</span>a)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-20"><span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb4-21"><span class="kw" style="color: #003B4F;">fn</span> mutable_borrowing(a<span class="op" style="color: #5E5E5E;">:&amp;</span><span class="kw" style="color: #003B4F;">mut</span> <span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">i32</span><span class="op" style="color: #5E5E5E;">&gt;</span>)<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb4-22">    a<span class="op" style="color: #5E5E5E;">.</span>push(<span class="dv" style="color: #AD0000;">45</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-23"><span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb4-24"> <span class="co" style="color: #5E5E5E;">//We can also return ownership to the caller</span></span>
<span id="cb4-25"><span class="kw" style="color: #003B4F;">fn</span> takes_and_return(a<span class="op" style="color: #5E5E5E;">:</span><span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">i32</span><span class="op" style="color: #5E5E5E;">&gt;</span>) <span class="op" style="color: #5E5E5E;">-&gt;</span> <span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">i32</span><span class="op" style="color: #5E5E5E;">&gt;{</span></span>
<span id="cb4-26">       a</span>
<span id="cb4-27"><span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb4-28"><span class="kw" style="color: #003B4F;">fn</span> moves_and_takes_ownership(_a<span class="op" style="color: #5E5E5E;">:</span><span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">i32</span><span class="op" style="color: #5E5E5E;">&gt;</span>)<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb4-29"> <span class="co" style="color: #5E5E5E;">//new_owner is cleaned here not in the main  </span></span>
<span id="cb4-30"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>Look at the function signature carefully. Just by looking at them, we can reason about what might they do. The second function call takes an immutable reference so we can guarantee that there is no mutation taken inside the function body. This is the same for methods where the self is the first parameter of the method.</p>
<blockquote class="blockquote">
<p><strong>&amp;self</strong> -immutable borrow.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>&amp;mut self</strong> -Mutable borrow so that we can mutate the self values inside the method body.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>self</strong> -Takes ownership, after that, we are no longer able to call any methods defined on the self if the return type is unit type i.e returns nothing.</p>
</blockquote>
<p><strong><em>Ownership/borrowing in Closure and the Move keyword</em></strong>:</p>
<p>The closure is an anonymous function that captures the surrounding environment either mutably or immutably depending on how it’s used inside the closure or moved inside the closure when <strong>Move</strong> keyword is used. As usual, the same rules apply. Move types moved to a new owner, copy types just deep copy the value.</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb5-1"><span class="kw" style="color: #003B4F;">fn</span> main() <span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb5-2">  <span class="kw" style="color: #003B4F;">let</span> <span class="kw" style="color: #003B4F;">mut</span> vector <span class="op" style="color: #5E5E5E;">=</span><span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">3</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-3">  <span class="kw" style="color: #003B4F;">let</span> <span class="kw" style="color: #003B4F;">mut</span> mutable_closure <span class="op" style="color: #5E5E5E;">=</span> <span class="op" style="color: #5E5E5E;">||</span>vector<span class="op" style="color: #5E5E5E;">.</span>push(<span class="dv" style="color: #AD0000;">56</span>)<span class="op" style="color: #5E5E5E;">;</span> <span class="co" style="color: #5E5E5E;">//implicitly mutably borrowed,</span></span>
<span id="cb5-4">  <span class="co" style="color: #5E5E5E;">//because of the push method called inside the closure </span></span>
<span id="cb5-5">  mutable_closure()<span class="op" style="color: #5E5E5E;">;</span> <span class="co" style="color: #5E5E5E;">//calling closure.</span></span>
<span id="cb5-6">  <span class="kw" style="color: #003B4F;">let</span> immutable_closure<span class="op" style="color: #5E5E5E;">=||{</span><span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{:?}"</span><span class="op" style="color: #5E5E5E;">,</span>vector)<span class="op" style="color: #5E5E5E;">;};</span><span class="co" style="color: #5E5E5E;">//immutably borrowed since we are reading.</span></span>
<span id="cb5-7">  immutable_closure()<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-8">  <span class="kw" style="color: #003B4F;">let</span> ownership_closure <span class="op" style="color: #5E5E5E;">=</span><span class="kw" style="color: #003B4F;">move</span> <span class="op" style="color: #5E5E5E;">||</span>vector<span class="op" style="color: #5E5E5E;">;</span> <span class="co" style="color: #5E5E5E;">//the closure is takes ownership by moving explicitly </span></span>
<span id="cb5-9">  <span class="co" style="color: #5E5E5E;">// println!("{:?}",m); //Use of moved value</span></span>
<span id="cb5-10">  <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{:?}"</span><span class="op" style="color: #5E5E5E;">,</span>takes_closure())<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-11"> <span class="kw" style="color: #003B4F;">let</span> copy_type<span class="op" style="color: #5E5E5E;">:</span><span class="dt" style="color: #AD0000;">f64</span> <span class="op" style="color: #5E5E5E;">=</span><span class="pp" style="color: #AD0000;">std::</span><span class="dt" style="color: #AD0000;">f64</span><span class="pp" style="color: #AD0000;">::consts::</span>PI<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-12"> <span class="kw" style="color: #003B4F;">let</span> moving <span class="op" style="color: #5E5E5E;">=</span> <span class="kw" style="color: #003B4F;">move</span><span class="op" style="color: #5E5E5E;">||</span>copy_type<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-13"> <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{} {}"</span><span class="op" style="color: #5E5E5E;">,</span>copy_type<span class="op" style="color: #5E5E5E;">,</span>moving())<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-14"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>These same procedures help to avoid accessing the objects once the object sends it to another thread via channels.</p>
<p>Region-based or Scope based memory/resource management i.e the values created and destroyed in lexical scope where they created and also prevent you to cause temporal memory safety. Even though region-based memory management is used to manage memory, rust uses the same idea to release the lock, close the files and sockets, and ends the borrows, and any other resources <strong>implicitly without human intervention as humans are good at forgetting things</strong>. This feels automatic and ergonomic since we don’t need explicitly call unlock on a mutex, close on file, or socket. This is really <strong>phenomenal</strong>.Rust knows well <strong>where</strong> to do <strong><em>implicit</em></strong> actions like cleaning resources and where to do <strong><em>explicit</em></strong> actions like numerical conversion, and cloning on heap data.</p>
<p><strong><em>Even more Weirdo</em></strong>:</p>
<p>Cyclone is a research programming language that introduces the concept of <strong>linear types(Ownership, in the case of rust)</strong> in a programming language. For more expressive capability linear types supports <em>sub-region types</em>,i.e borrowing. Rust inherits ideas from the cyclone including ownership, and borrowing. Linear and subtypes avoid the <strong><em>Spooky action at a distance</em></strong>.That’s why the order of calling function important.</p>
<p>Generics is a way to reduce code duplication and provide better abstraction with static and dynamic dispatch. Normally generics in c++ are abstract over a type and const. But in rust, we have <strong><em>generic over lifetime</em></strong> or <strong><em>generic over sub-linear types</em></strong>. These sophisticated implementations make rust have a steep learning curve than any other programming language that came to exist except for some advanced type system languages like Haskell. <em>Swift</em> also has a proposal for integrating ownership into the language to manage memory efficiently.</p>
<p><strong>References</strong>:</p>
<p><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Rust official Book about Ownership</a></p>
<p><a href="https://cyclone.thelanguage.org/wiki/">Cyclone</a></p>
<p><a href="https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md">Swift proposal for ownership</a></p>



 ]]></description>
  <category>Code</category>
  <category>Theory</category>
  <guid>https://sanjuvi.github.io/Blog/posts/Ownership-and-borrowing-in-rust/index.html</guid>
  <pubDate>Sun, 26 Feb 2023 08:00:00 GMT</pubDate>
  <media:content url="https://sanjuvi.github.io/Blog/posts/Ownership-and-borrowing-in-rust/image.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Memory safety, what it is?</title>
  <dc:creator>Sanjeevi</dc:creator>
  <link>https://sanjuvi.github.io/Blog/posts/Memory-Unsafety/index.html</link>
  <description><![CDATA[ 




<p>A snippet from <a href="https://www.memorysafety.org/docs/memory-safety/">PROSSIMO</a></p>
<blockquote class="blockquote">
<p>Memory safety is a property of some programming languages that prevent programmers from introducing certain types of bugs related to how memory is used. Since memory safety bugs are often security issues, memory-safe languages are more secure than languages that are not memory safe.</p>
</blockquote>
<p>Why memory safety is a big deal?</p>
<blockquote class="blockquote">
<p>70% of the vulnerabilities Microsoft assigns a CVE(Common Vulnerability Exposures) each year continue to be memory safety issues. –Microsoft Security Response Centre</p>
</blockquote>
<blockquote class="blockquote">
<p>Around 70% of our high-severity security bugs are memory unsafety problems (that is, mistakes with C/C++ pointers). Half of those are use-after-free bugs. <a href="https://www.chromium.org/Home/chromium-security/memory-safety/"></a></p>
</blockquote>
<p>Raw pointers are root cause of the memory safety violation since allocating heap data involves pointers.Raw pointer as the name suggest ,carry no information other than pointing to memory.So ownership,lifetime of a pointer not controlled by compiler.They are too unrestricted,this is useful for interacting with hardware since the hardware is inherently unsafe but safe through abstraction-like types, that’s why rust has <strong>Unsafe</strong> escape hatch to break the compiler restriction.</p>
<p>Memory allocations or pointers are ergonomics to use in rust than in c/c++ and also memory safe.There is no explicit equivalent new/delete or malloc/free keyword to allocate memory on the heap.Allocation and deallocation of memories in rust is automated by the compiler at compile time.Rust provides an abstraction for the allocation of heap memory.</p>
<p>Advances in type theories help to mitigate memory related errors statically by the type systems without using runtime like garbage collectors.Now look at how rust-type systems prevent memory-related errors by statically i.e without actually running a program.</p>
<p><strong>Memory Related Bugs</strong></p>
<ul>
<li>Using uninitialized variable</li>
<li>Null pointers</li>
<li>Buffer over-read and over-write</li>
<li>Integer Overflow</li>
<li>Use after free</li>
<li>Double free</li>
<li>Memory leak</li>
</ul>
<p>The above errors are mitigated by memory-safe languages which use <strong>Garbage Collector</strong> though not all. What’s so unique about rust is that these errors are ruled out at compile time except overflow which is determined at runtime.This is an important distinction that makes rust different from garage collected and c/c++.Don’t worry about the rust syntax now. Use this <a href="https://play.rust-lang.org/">link</a> to execute the code yourself in the browser.</p>
<p><strong>Use of Uninitialized Variable</strong></p>
<p>If you declare a variable and it’s uninitialized if the initial value is not given by the programmer. The uninitialized variable contains random values or may be private data.GCed language uses control flow analysis to prevent using uninitialized variables.Rust does the same. In rust the variable must be initialized before it’s used.This is true for structs and enums constructors.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb1-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;">let</span> m<span class="op" style="color: #5E5E5E;">:</span><span class="dt" style="color: #AD0000;">i32</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-3">    <span class="co" style="color: #5E5E5E;">//m=10;</span></span>
<span id="cb1-4">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{}"</span><span class="op" style="color: #5E5E5E;">,</span>m)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-5"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>You get a compile-time error.The type annotation is needed here since without initializing the variable with a value,rust won’t infer the type of the variable.</p>
<p><strong>Null pointers</strong> Is a pointer that points to nothing.It’s useful when something is may be not there or maybe there like Schrödinger’s cat.But it’s not enforced by the compiler,forgot to handle the possible results in a crash or silently continuing with wrong inputs since in c/c++ implicitly converts between types.Even in GCed languages at runtime i.e it will prevent further processing even when the subsequent task is not depend on them. There is no equivalent of c-NULL or c++ nullpointer or go nil in rust.It is mitigated through the type system.Rust uses a enum type to encode the logic of a null pointer.</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb2-1"><span class="kw" style="color: #003B4F;">enum</span> <span class="dt" style="color: #AD0000;">Option</span><span class="op" style="color: #5E5E5E;">&lt;</span>T<span class="op" style="color: #5E5E5E;">&gt;{</span></span>
<span id="cb2-2"><span class="cn" style="color: #8f5902;">Some</span>(T)<span class="op" style="color: #5E5E5E;">,</span></span>
<span id="cb2-3"><span class="cn" style="color: #8f5902;">None</span></span>
<span id="cb2-4"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>Here enum is a sum type i.e either this variant or another variant not both unlike struct.So we can’t dereference like this is pointer, try to do is compile the error. We won’t accidentally forget to miss another variant (some <strong>or</strong> none).The pattern must be exhaustive i.e cover everything otherwise compiler issues an error, not a warning.This is true for as long as we rely rust abstraction.If we are not handling errors then they are guaranteed to be <strong>non-null values</strong>.</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb3-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb3-2"><span class="kw" style="color: #003B4F;">let</span> m<span class="op" style="color: #5E5E5E;">=</span><span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">3</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">4</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">5</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-3"><span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{:?}"</span><span class="op" style="color: #5E5E5E;">,</span>m<span class="op" style="color: #5E5E5E;">.</span>get(<span class="dv" style="color: #AD0000;">5</span>))<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//it returns none if the index if out of bounds otherwise returns some with elements.</span></span>
<span id="cb3-4"><span class="co" style="color: #5E5E5E;">//println!("{:?}",m[5]); //This causes panic,this is a runtime error as in python.</span></span>
<span id="cb3-5"><span class="kw" style="color: #003B4F;">let</span> i<span class="op" style="color: #5E5E5E;">=</span><span class="cn" style="color: #8f5902;">Some</span>(<span class="dv" style="color: #AD0000;">5</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-6"><span class="cf" style="color: #003B4F;">match</span> i<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb3-7">some(i)<span class="op" style="color: #5E5E5E;">=&gt;</span><span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{i}"</span>)<span class="op" style="color: #5E5E5E;">,</span></span>
<span id="cb3-8"></span>
<span id="cb3-9"><span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb3-10"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p><strong>Buffer Overflow</strong></p>
<p>Accessing elements that are not part of your data, whether it is stored on stack or heap, is a memory error. It will lead to security vulnerability since we were reading or writing memory that is not part of our data. Let’s try to access elements both from stack-allocated and heap-allocated data in rust. Notes on what is <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">stack and heap</a>, if you are curious what they are.</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb4-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb4-2">    <span class="kw" style="color: #003B4F;">let</span> stack_data <span class="op" style="color: #5E5E5E;">=</span> [<span class="dv" style="color: #AD0000;">0</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">3</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">4</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-3">    <span class="kw" style="color: #003B4F;">let</span> heap_data <span class="op" style="color: #5E5E5E;">=</span> <span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">0</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">3</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">4</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-4">  <span class="co" style="color: #5E5E5E;">//  let stack_invalid_data = stack_data[5];//Length of the array is 5 and it's zero-indexed.</span></span>
<span id="cb4-5">  <span class="co" style="color: #5E5E5E;">//  println!("{}",stack_invalid_data);</span></span>
<span id="cb4-6">    <span class="kw" style="color: #003B4F;">let</span> heap_invalid_data <span class="op" style="color: #5E5E5E;">=</span> heap_data[<span class="dv" style="color: #AD0000;">5</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-7">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{}"</span><span class="op" style="color: #5E5E5E;">,</span>heap_invalid_data)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb4-8"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>Rust will panic at runtime. Panicking in rust is to stop the program immediately instead of continuing further with the wrong data.</p>
<p><strong>Integer Overflow</strong></p>
<p>Integer overflow is like the buffer overflow. Integers have limits that how many values can represent depending on the bits used to represent that. There are two integer types signed and unsigned.Signed integer(negative numbers) only represent values from <img src="https://latex.codecogs.com/png.latex?-%7B2%7D%5E%20%7B(n-1)%7D%20to%20+2%5E%20%7B(n-1)%7D-1"> and unsigned integer represent values from <img src="https://latex.codecogs.com/png.latex?0%20to%202%5En%20-1">.For eg, 8-bit signed integers only represent -128 to 127 values but unsigned integers represent more values than signed integers since they start from zero.Rust std libraries provide min and max values of the signed and unsigned integers. Let’s use that..</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb5-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb5-2">   <span class="kw" style="color: #003B4F;">let</span> signed_8bit_min <span class="op" style="color: #5E5E5E;">=</span> <span class="dt" style="color: #AD0000;">i8</span><span class="pp" style="color: #AD0000;">::</span><span class="cn" style="color: #8f5902;">MIN</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-3">   <span class="kw" style="color: #003B4F;">let</span> signed_8bit_max <span class="op" style="color: #5E5E5E;">=</span> <span class="dt" style="color: #AD0000;">i8</span><span class="pp" style="color: #AD0000;">::</span><span class="cn" style="color: #8f5902;">MAX</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-4">   <span class="kw" style="color: #003B4F;">let</span> unsigned_64bit_min <span class="op" style="color: #5E5E5E;">=</span> <span class="dt" style="color: #AD0000;">u64</span><span class="pp" style="color: #AD0000;">::</span><span class="cn" style="color: #8f5902;">MIN</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-5">   <span class="kw" style="color: #003B4F;">let</span> unsigned_64bit_max <span class="op" style="color: #5E5E5E;">=</span> <span class="dt" style="color: #AD0000;">u64</span><span class="pp" style="color: #AD0000;">::</span><span class="cn" style="color: #8f5902;">MAX</span><span class="op" style="color: #5E5E5E;">;</span> </span>
<span id="cb5-6">   <span class="co" style="color: #5E5E5E;">//Only 8,6,32,64,128 bits are available for integer</span></span>
<span id="cb5-7">   <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{}"</span><span class="op" style="color: #5E5E5E;">,</span>signed_8bit_Max<span class="op" style="color: #5E5E5E;">+</span><span class="dv" style="color: #AD0000;">1</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb5-8"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>Adding or subtracting one to the maximum or minimum values of any integer bits respectively causes overflow.In debug mode rust compiles with an error message.</p>
<p><strong>Use after free</strong></p>
<p>This bug happens when accessing heap or dynamically allocated data after it is freed or after released to the operating system.In c/c++ accessing values after freeing memory cause segfaults.But in rust it’s compiling time error.Why this is a bug,once heap memory is released to the operating system the memory is uninitialized or used by another program once it’s freed. So accessing the freed memory crashes the system, which causes segfaults in c/c++ when run.How rust prevents this at compile.Let’s look at the code below,</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb6-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb6-2">  <span class="kw" style="color: #003B4F;">let</span> s<span class="op" style="color: #5E5E5E;">=</span><span class="dt" style="color: #AD0000;">String</span><span class="pp" style="color: #AD0000;">::</span>from(<span class="st" style="color: #20794D;">"Rustacean"</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-3">  call(s)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-4">  <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{}"</span><span class="op" style="color: #5E5E5E;">,</span>s)<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//Here we access s which is freed when the call scope ends.</span></span>
<span id="cb6-5"><span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb6-6"><span class="kw" style="color: #003B4F;">fn</span> call(s<span class="op" style="color: #5E5E5E;">:</span><span class="dt" style="color: #AD0000;">String</span>)<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb6-7">    s<span class="op" style="color: #5E5E5E;">.</span>push(<span class="ch" style="color: #20794D;">'s'</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-8"><span class="op" style="color: #5E5E5E;">}</span><span class="co" style="color: #5E5E5E;">//When the owner of heap allocated data goes out of scope,it's freed automatically.</span></span></code></pre></div>
<p>Because of the single ownership restriction,when s is passed to fn the function call takes ownership so the function is responsible for cleaning the memory.But we try to access in the main function after it’s transferred or moved ,which is forbidden by the rust compiler. Rust won’t compile this code.</p>
<p><strong>Dangling pointer</strong></p>
<p>Returning or storing a reference to the pointer whether it is stack allocated or heap allocated is a bad idea,when they are used after freeing the memory in c/c++.This is called dangling pointers since they point at invalid memory.But rust refuses to compile at all with this bug.</p>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb7-1"></span>
<span id="cb7-2"><span class="co" style="color: #5E5E5E;">//Returning reference to the caller</span></span>
<span id="cb7-3"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb7-4">    <span class="kw" style="color: #003B4F;">let</span> m<span class="op" style="color: #5E5E5E;">=</span>call()<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//pointing at anywhere if rust allowed</span></span>
<span id="cb7-5">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{}"</span><span class="op" style="color: #5E5E5E;">,</span>m)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb7-6"><span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb7-7"><span class="kw" style="color: #003B4F;">fn</span> call()<span class="op" style="color: #5E5E5E;">-&gt;&amp;</span><span class="ot" style="color: #003B4F;">'static</span> <span class="dt" style="color: #AD0000;">String</span><span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb7-8">    <span class="kw" style="color: #003B4F;">let</span> m<span class="op" style="color: #5E5E5E;">=</span><span class="dt" style="color: #AD0000;">String</span><span class="pp" style="color: #AD0000;">::</span>from(<span class="st" style="color: #20794D;">"Dangling Pointer"</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb7-9">    <span class="op" style="color: #5E5E5E;">&amp;</span>m</span>
<span id="cb7-10"><span class="op" style="color: #5E5E5E;">}</span><span class="co" style="color: #5E5E5E;">//This point the m is freed</span></span></code></pre></div>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb8-1"><span class="co" style="color: #5E5E5E;">//storing reference and used after it's freed</span></span>
<span id="cb8-2"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb8-3"></span>
<span id="cb8-4">    <span class="kw" style="color: #003B4F;">let</span> m<span class="op" style="color: #5E5E5E;">=</span><span class="dt" style="color: #AD0000;">String</span><span class="pp" style="color: #AD0000;">::</span>from(<span class="st" style="color: #20794D;">"Dangling"</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb8-5">    <span class="kw" style="color: #003B4F;">let</span> s<span class="op" style="color: #5E5E5E;">=&amp;</span>m<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb8-6">    drop(m)<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//explicitly freed</span></span>
<span id="cb8-7">    <span class="co" style="color: #5E5E5E;">//m.push_str("Fourth"); //Mutable access</span></span>
<span id="cb8-8">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{}"</span><span class="op" style="color: #5E5E5E;">,</span>s)<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//Here s is not valid so rust reject this code</span></span>
<span id="cb8-9"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p><strong>Double free </strong></p>
<p>The double free error happens when heap-allocated memory calls free or delete on that memory and then we try to free that memory again eg: Calling two free() in <em>c</em> or two delete() in <em>c++</em>.Why the heck we want to free the memory twice, humans are not machine,in large code bases programmers free the memory twice by accident. It will crash the program with segfaults because when first call to free ,it will clear the data in that location then it stores the different data in that location when some program requests memory from the operating system allocator, so after calling the second free on the same data will clear the data which may cause another program to crash and using that memory to have undefined behavior.Rust prevents this by having <strong>single ownership</strong> rule i.e every variable exactly has one owner except <strong>smart pointer types</strong>.If we assign the <strong>movable type</strong> to a new variable,the new variable is the new owner and invalidates the old one.Let’s demonstrate how rust avoids double free.</p>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb9-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb9-2">    <span class="kw" style="color: #003B4F;">let</span> m<span class="op" style="color: #5E5E5E;">=</span><span class="dt" style="color: #AD0000;">String</span><span class="pp" style="color: #AD0000;">::</span>from(<span class="st" style="color: #20794D;">"Hello,Fellows"</span>)<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//here heap allocated data initialized.</span></span>
<span id="cb9-3">    <span class="kw" style="color: #003B4F;">let</span> n<span class="op" style="color: #5E5E5E;">=</span>m<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//here m is moved to n,now m is uninitialized.exactly one drop is called when the owner goes out of scope.</span></span>
<span id="cb9-4">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{}-{}"</span><span class="op" style="color: #5E5E5E;">,</span>m<span class="op" style="color: #5E5E5E;">,</span>n)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb9-5"><span class="op" style="color: #5E5E5E;">}</span><span class="co" style="color: #5E5E5E;">//here only n will freed implicitly by the compiler ,not both m and n.</span></span></code></pre></div>
<div class="sourceCode" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb10-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb10-2">    <span class="kw" style="color: #003B4F;">let</span> m<span class="op" style="color: #5E5E5E;">=</span><span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">3</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">5</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb10-3">    drop(m)<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//explicitly freed once</span></span>
<span id="cb10-4">    drop(m)<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//try to clean the memory twice ,but rust complies with 'Use of moved value'</span></span>
<span id="cb10-5"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p><em>Drop</em> is the rust equivalent of free, delete in c++. The rust compiler inserts the drop automatically when the owner goes out of scope.(Scope -a region where memory accesses are valid). This bug does not happen in GCed language where the GC only cleans the memory when there is no reference to that object but it’s not predictable.</p>
<p><strong>Memory leak</strong>:</p>
<p>In c/c++ forgetting to release the memory to the os once we have done with it resulted in memory leaks. Manual memory management is efficient because we can use larger memory and then release the memory by calling delete at <strong>predictable</strong> point in code so that we can use memory for the further task without exhausting the system memory.But forgetting to that prevents other programs to use the resources.Look at the below code ,looks like the file is not closed and not handling failure…</p>
<div class="sourceCode" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb11-1"><span class="kw" style="color: #003B4F;">use</span> <span class="pp" style="color: #AD0000;">std::fs::</span>File<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb11-2"><span class="kw" style="color: #003B4F;">use</span> <span class="pp" style="color: #AD0000;">std::io::prelude::</span><span class="op" style="color: #5E5E5E;">*;</span></span>
<span id="cb11-3"><span class="kw" style="color: #003B4F;">fn</span> main() <span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb11-4"></span>
<span id="cb11-5">create_file()<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb11-6"></span>
<span id="cb11-7"><span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb11-8"><span class="kw" style="color: #003B4F;">fn</span> create_file()<span class="op" style="color: #5E5E5E;">-&gt;</span><span class="pp" style="color: #AD0000;">std::io::</span><span class="dt" style="color: #AD0000;">Result</span><span class="op" style="color: #5E5E5E;">&lt;</span>()<span class="op" style="color: #5E5E5E;">&gt;{</span></span>
<span id="cb11-9">    <span class="kw" style="color: #003B4F;">let</span> <span class="kw" style="color: #003B4F;">mut</span> file<span class="op" style="color: #5E5E5E;">=</span><span class="pp" style="color: #AD0000;">File::</span>create(<span class="st" style="color: #20794D;">"text.txt"</span>)<span class="op" style="color: #5E5E5E;">?;</span></span>
<span id="cb11-10">    file<span class="op" style="color: #5E5E5E;">.</span>write(<span class="st" style="color: #20794D;">b"There is no need to close file explicitly as there is no close method </span></span>
<span id="cb11-11"><span class="st" style="color: #20794D;">The file close implicitly when the scope ends"</span>)<span class="op" style="color: #5E5E5E;">?;</span></span>
<span id="cb11-12">    <span class="cn" style="color: #8f5902;">Ok</span>(())</span>
<span id="cb11-13"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>There are no leaks here. Rust uses scoped management for releasing memory and other resources when they are goes out of scope. This is how rust manages sockets,locks,files.Garabge collector only help you with memory errors not resources.In python <strong>with</strong> statement used to release the resources when the scope ends,other wise it’s still uses that file until the program terminates. Other languages provide similar mechanisms to handle resources other than memories.The <strong>?</strong> operator is an ergonomic way to handle failure in rust,on success it returns nothing i.e () ,on failure it returns early with error without further processing.</p>
<p><strong>Iterator Invalidation</strong></p>
<p>Create a data structure, pass them to the function as two parameters. The same data structure tries to add elements to it at each loop sate but it’s infinitely run because the loop counts is increased each time a loop enters the body. But it’s not the problem though, it is used after freed memory whenever the vector doesn’t have space to store it , it will move to a new place then a shared pointer reads invalid memory if we are allowed this operation it’s writing data to other data structures.</p>
<div class="sourceCode" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb12-1"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb12-2"> <span class="kw" style="color: #003B4F;">let</span> <span class="kw" style="color: #003B4F;">mut</span> v<span class="op" style="color: #5E5E5E;">:</span><span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">usize</span><span class="op" style="color: #5E5E5E;">&gt;</span> <span class="op" style="color: #5E5E5E;">=</span> <span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">3</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb12-3"> <span class="kw" style="color: #003B4F;">let</span> v1<span class="op" style="color: #5E5E5E;">:</span><span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">usize</span><span class="op" style="color: #5E5E5E;">&gt;</span> <span class="op" style="color: #5E5E5E;">=</span> <span class="pp" style="color: #AD0000;">vec!</span>[<span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">23</span><span class="op" style="color: #5E5E5E;">,</span><span class="dv" style="color: #AD0000;">3</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb12-4"> call( <span class="op" style="color: #5E5E5E;">&amp;</span><span class="kw" style="color: #003B4F;">mut</span> v<span class="op" style="color: #5E5E5E;">,</span> <span class="op" style="color: #5E5E5E;">&amp;</span>v1)<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//passing mutable and immutable references</span></span>
<span id="cb12-5"> <span class="co" style="color: #5E5E5E;">//call( &amp;mut v,&amp;v);</span></span>
<span id="cb12-6"> <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">" {:?} "</span><span class="op" style="color: #5E5E5E;">,</span> v)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb12-7">    <span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb12-8"><span class="kw" style="color: #003B4F;">fn</span> call(s<span class="op" style="color: #5E5E5E;">:</span> <span class="op" style="color: #5E5E5E;">&amp;</span><span class="kw" style="color: #003B4F;">mut</span> <span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">usize</span><span class="op" style="color: #5E5E5E;">&gt;,</span>s1<span class="op" style="color: #5E5E5E;">:</span> <span class="op" style="color: #5E5E5E;">&amp;</span><span class="dt" style="color: #AD0000;">Vec</span><span class="op" style="color: #5E5E5E;">&lt;</span><span class="dt" style="color: #AD0000;">usize</span><span class="op" style="color: #5E5E5E;">&gt;</span>)<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb12-9">    <span class="cf" style="color: #003B4F;">for</span> i <span class="kw" style="color: #003B4F;">in</span> s1<span class="op" style="color: #5E5E5E;">.</span>iter() <span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb12-10">        s<span class="op" style="color: #5E5E5E;">.</span>push(<span class="op" style="color: #5E5E5E;">*</span>i)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb12-11">    <span class="op" style="color: #5E5E5E;">}</span></span>
<span id="cb12-12"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>The above code tries to add elements of v1 to v and compiles successfully. But what if we pass the same vector to the function? Try uncommenting the second function call <strong>call()</strong>, then look at what the compiler says.It says,</p>
<blockquote class="blockquote">
<p>cannot borrow <code>v</code> as immutable because it is also borrowed as mutable.</p>
</blockquote>
<p>What is remarkable is that just looking at the function signature rust would able to detect this. Compile the above code by removing the for loop inside a function body. Rust has a restriction that either <strong>One mutable reference(write) to the object or Multiple immutable reference(read)</strong> at a time.</p>
<p>Why this is a bug? There is two things that happen if a program is allowed, either the loop run infinitely because each time the for loop runs it increases the length of the vector which is infinite since pushing elements to the same vector increases the length, or crashes the program , pushing more elements to the vector increase the capacity which in turns allocate more memory from operating system then move the data to a new location this is same as use after free. Run this python code in your editor or online python interpreter</p>
<div class="sourceCode" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1">data<span class="op" style="color: #5E5E5E;">=</span>[<span class="dv" style="color: #AD0000;">1</span>,<span class="dv" style="color: #AD0000;">2</span>,<span class="dv" style="color: #AD0000;">4</span>]</span>
<span id="cb13-2"><span class="cf" style="color: #003B4F;">for</span> i <span class="kw" style="color: #003B4F;">in</span> data: <span class="co" style="color: #5E5E5E;">#reads the data i.e iterating </span></span>
<span id="cb13-3">    data.append(i) <span class="co" style="color: #5E5E5E;">#after this the list length is increased thus for loop iteration.</span></span></code></pre></div>
<p><strong>Concurrency Bug</strong>:</p>
<p>Concurrency bugs are related to memory bugs where without synchronization the memory access is incorrect because of a race condition where multiple threads are accessing the same memory. Writing concurrency programs is not an easy task,only experienced programmers can write still buggy though. But functional programming like haskell,erlang,elixir or imperative like go provide a better abstraction for writing concurrency without much experience in concurrency programs. But they are still misused if we are not careful.</p>
<p>Rust forces you to use synchronization for shared memory before sharing between threads. Because of the restriction on <strong>Aliasing and Mutatation </strong> we can write low level concurrency as in c/c++ but with much more safety and guarantee.In below code, there is no way to access the data inside the mutex without locking it first which gives exclusive access. Note that this is a single-threaded code.</p>
<div class="sourceCode" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb14-1"><span class="kw" style="color: #003B4F;">use</span> <span class="pp" style="color: #AD0000;">std::sync::</span>Mutex<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb14-2"><span class="kw" style="color: #003B4F;">fn</span> main()<span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb14-3">    <span class="kw" style="color: #003B4F;">let</span> i<span class="op" style="color: #5E5E5E;">=</span><span class="pp" style="color: #AD0000;">Mutex::</span>new(<span class="dv" style="color: #AD0000;">45</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb14-4">   <span class="op" style="color: #5E5E5E;">*</span>i<span class="op" style="color: #5E5E5E;">+=</span><span class="dv" style="color: #AD0000;">10</span><span class="op" style="color: #5E5E5E;">;</span> <span class="co" style="color: #5E5E5E;">//type `Mutex&lt;{integer}&gt;` cannot be dereferenced,We are forced to use lock on mutex</span></span>
<span id="cb14-5">    <span class="kw" style="color: #003B4F;">let</span> l<span class="op" style="color: #5E5E5E;">=</span>i<span class="op" style="color: #5E5E5E;">.</span>lock()<span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//Even though we lock the data inside of mutex,we still can't acess the data unless    handling the error since the return type is Result which must be hadled via pattern matching or call unwrap to get the value inside</span></span>
<span id="cb14-6">    <span class="co" style="color: #5E5E5E;">//let mut l=i.lock().unwrap();//without mut we can't mutate the data </span></span>
<span id="cb14-7">    <span class="op" style="color: #5E5E5E;">*</span>l<span class="op" style="color: #5E5E5E;">+=</span><span class="dv" style="color: #AD0000;">10</span><span class="op" style="color: #5E5E5E;">;</span><span class="co" style="color: #5E5E5E;">//</span></span>
<span id="cb14-8">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{:?}"</span><span class="op" style="color: #5E5E5E;">,</span>l)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb14-9"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>But where do we unlock the mutex? We don’t, when the scope ends the lock is unlocked automatically. The same procedure is to help to automatically close the file above.Just in three lines of code ,we can see that how rust prevent you to compile the code without using APIs properly.Rust supports more than shared memory model concurrency.</p>
<p>But Gc Language doesn’t save you from concurrency bugs, other resources like files, sockets,databases without putting a restriction on the design of the language like immutable data structure, lifetime of objects or scoped objects. But they are not forced by the language runtime thus it’s easy to make mistakes.</p>
<p>Being memory safety doesn’t mean being immune to security-related problems. What about the other 30 percent of vulnerability in Microsoft and chromium, which must be mitigated by source code analysis and extensive testing?</p>
<p>Just using memory-safe languages makes certain memory-related bugs not existed in the first place. But when writing performance-critical software, the choices include c/c++ but they are not safe by default. Now we have rust that is safe and runs on bare metal as it lacks a runtime.</p>
<p>Android chose rust to write new native code and kotlin, java at a high level.</p>
<p>Apple creates swift as memory safe and modern with a deterministic approach to memory management.</p>
<p><a href="https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html?m=1">Rust in Android</a>.</p>
<p><a href="https://security.googleblog.com/2023/01/supporting-use-of-rust-in-chromium.html?m=1">Rust in chromium</a></p>
<p><a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Fearless concurrency with rust</a>.</p>
<p><a href="https://msrc-blog.microsoft.com/2019/07/18/we-need-a-safer-systems-programming-language/">Microsoft chooses Rust for writing new code</a>.</p>
<p><a href="https://alexgaynor.net/2019/aug/12/introduction-to-memory-unsafety-for-vps-of-engineering/">Why Memory safety is important</a></p>
<p><a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">Seriousness of NULL</a></p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL50-CPP.+Do+not+define+a+C-style+variadic+function">C++ Rules to follow in order to doesn’t cause undefined behavior at runtime</a>. In case of rust,the compiler has your back i.e bugs are caught by the compiler.</p>



 ]]></description>
  <category>Code</category>
  <category>Theory</category>
  <guid>https://sanjuvi.github.io/Blog/posts/Memory-Unsafety/index.html</guid>
  <pubDate>Tue, 14 Feb 2023 08:00:00 GMT</pubDate>
  <media:content url="https://sanjuvi.github.io/Blog/posts/Memory-Unsafety/image.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>What is Rust?</title>
  <dc:creator>Sanjeevi </dc:creator>
  <link>https://sanjuvi.github.io/Blog/posts/Rust-pl/index.html</link>
  <description><![CDATA[ 




<p><strong>Rust</strong> is an emerging new system programming language. But what is a system programming language? A system programming language is like any other programming language except it provides full control over hardware, manual memory management, abstraction without overhead like c++ to implement system-level software, and runs on bare metal(Without any operating system). So why another system programming language since we have c/c++?</p>
<p><strong>What others tell about rust</strong></p>
<blockquote class="blockquote">
<p>Linus Torvalds, the creator of Linux, considers rust as a second language for kernel development. This is somewhat intriguing since Linux doesn’t consider c++ as a secondary language</p>
</blockquote>
<p>The quotes below are from Microsoft Azure CTO Mark Russinovich in Twitter.</p>
<blockquote class="blockquote">
<p>Speaking of languages, it’s time to halt starting any new projects in C/C++ and use Rust for those scenarios where a non-GC language is required. For the sake of security and reliability. the industry should declare those languages as deprecated.</p>
</blockquote>
<blockquote class="blockquote">
<p>The microsoft Security Response Center (MSRC) stated “we think that Rust represents the best alternative to C and C++ currently available.</p>
</blockquote>
<p>Rust is most loved by developers for five years row, a survey conducted by StackOverflow.</p>
<p>now look at the feature, the language provides.</p>
<p><strong>Zero cost abstraction</strong> Abstraction in <em>the system</em> programming language doesn’t impose any additional overhead. Because it’s a system programming language introducing abstraction means reducing the development time, less code, expressive.More on <a href="https://sanjuvi.github.io/Blog/posts/Zero-cost-abstraction/">here</a>.</p>
<p><strong>AOT</strong>(Ahead of Time)</p>
<p>Rust compiler(rustc) is a gatekeeper to refuse a code that violates the compiler rules without even running a program thus the execution and startup speed is low once an executable file is generated.</p>
<p><strong>Guaranteed memory safety</strong></p>
<ul>
<li>Dangling pointer, double free, and null pointer dereferences are memory errors that are detected at compile time i.e the code with these errors doesn’t compile. Integer overflow and buffer overflow are detected at runtime, causing the rust program to panic at runtime instead of continuing with the wrong input which leads to undefined behavior. As long as the unsafe sound we are free of memory-related bugs.</li>
</ul>
<p><strong>Move Semantics</strong></p>
<ul>
<li>In rust, a type either copies or move. This distinction makes certain behavior injected when variables go out of scope by the compiler without the programmer’s intent. Primitive types like Int, Float, bool, and char are copy types i.e they are cheap to make a copy. Dynamically allocated types are movable i.e when assigned to a new variable, the old one is uninitialized, this prevents double-free error since only one owner for the variable except for smart pointers.</li>
</ul>
<p><strong>Fearless concurrency</strong>.</p>
<ul>
<li><p>Today consumer pc hardware brings more cores than a fast processor. Concurrency is way to increase throughput of a program.But implementing concurrency have its own risk like <em>race condition</em> (ordering of task is nondeterministic),<em>data races</em> (multiple threads are accessing and writing to same memory without synchronization which leads to data inconsistent), <em>Deadlock</em> (form cycle prevent to release memory thus leads memory leaks).Cncurrency in rust is a low-risk operation than c/c++,java since rustc has your back.</p></li>
<li><p>Concurrency bug is detected at <strong>compile time</strong>. This is significant because concurrency bugs are much harder to reproduce as they were time-dependent (non-deterministic).There are libraries that rust provides to implement synchronization and lock-free concurrency safely without any data corruption whatsoever.</p></li>
</ul>
<p><strong>Tools and productivity</strong></p>
<p><em>Cargo</em> -a build tool and a package manager like Pip for python,Npm fo js but for a system PL.</p>
<p><em>Clippy</em> command used to find non-idiomatic rust like ESLinter for js.</p>
<p><em>Rustfmt</em> command line tool to standardize coding style like pretty quick for js.</p>
<p><em>Rustup</em> -Command line tool to install rust, rust components cargo,targets for cross-compilation, change the rustc version(stable,nightly,beta)</p>
<p><em>Rust Language Server(rls)</em> used in intelligence IDE to provide syntax highlighting,code completion, pointing errors.</p>
<p><em>Rust Docs</em> includes std library documentation, rust book, rust reference book when installing rust locally.</p>
<p><em>RustDoc</em> Generating documents embedded in rust source code via ‘///’ and then rendering on Doc.rs</p>
<p>Build in testing framework via <em>test</em> macros.</p>
<p>Module system to manage large programs.</p>
<p>Because rust is a system programming language it supports conditional compilation,staticlib,dynamic link library.</p>
<p><em><a href="play.rust-lang.org/">Rust playground</a></em> for playing with the language instantly in the web browser without installing rust locally.</p>
<p>Rust is a modern system programming language in addition to memory safe <strong>without using Garbage Collector</strong>. Is modern in the sense that these features are available in high-level dynamic programming languages not implemented in system programming languages(In terms of their safe use). Functional programming features are included (In the context of Haskell-a pure functional programming language)</p>
<ul>
<li><p>Unit type-A function without explicit return type returns unit type ‘()-an empty tuple’.It’s like a void in c/c++</p></li>
<li><p>pattern matching-Pattern must be exhaustive,cover all possible cases otherwise get a compile error.</p></li>
<li><p>Algebraic data types(Enums)-This is useful in handling errors since rust doesn’t have a nullpointer. Super handy with pattern matching.</p></li>
<li><p>lazy evaluation-Iterators in rust are lazy, they are evaluated as they are requested not at once unless consumed otherwise.</p></li>
<li><p>Rust is an expression-oriented language. This makes the code look cleaner.</p></li>
<li><p>Traits are equivalent to type classes in Haskell.</p></li>
<li><p>Type aliasing increase the readability by making long names with short name wherever they are used.</p></li>
<li><p>Immutability,type deduction,error as code.</p></li>
</ul>
<p><strong>Other Features and Community</strong></p>
<p>Supports <em>UTF-8</em> out of the box. Thus we can use more languages other than English. We can use emojis, scientific symbols, and other foreign languages.</p>
<p><strong>Ergonomics</strong> to use language features than in the c/c++ counterparts.</p>
<p><em>Generics</em> Reduce code duplication. Supports static dispatch along with compiler optimization and virtual dispatch via trait object at runtime.</p>
<p><em>Hygienic Macros</em>-To generate boilerplate rust code for you , expanded when compiling so your code looks clean.</p>
<p><em>Closure</em> anonymous function.You can do an interesting thing with them without worrying about safety.</p>
<p><em>Robust error handling strategies</em> through Result &amp; Option Type,using from ,into traits through ? operator.You never forgot to check error as the compiler forces you to do it ,the exhaustive nature of pattern matching.</p>
<p><em><a href="https://crates.io">Crates.io</a></em> a package registry for rust opensource libraries which cargo uses interanlly when building.</p>
<p><em>Backward compatibility</em>-This is important for evolving language feature as well as not breaking the code due to introducing new features into the language.This is reason why c/C++ barely introduces any major features or it will break the old code since it’s already span millions of lines of code in production.</p>
<p><strong>Automatic scoped management</strong> for memory ,non_memory resources,locks,smart pointers are phenomenal since no human intervention is needed and also no runtime cost for that(More on that later).It’s <em>RAII</em>(Resource acquistion is initialization) principle from c++ for managing resources.</p>
<p><em><a href="https://foundation.rust-lang.org/">Rust Foundation</a></em> is backed by big players that include Microsoft, Meta, Dropbox, Arm, Google, Amazon ,Shopify and others.Rust is a future-proof language.</p>
<p><em>Compile errors</em> contain rich information about what went wrong ,where that happened if code doesn’t compile and also suggests fixing that.This is important since rust introduces unique concepts Like <strong>ownership, borrowing,lifetime</strong> to rule out use after free, double free, dangling pointer, iterator invalidation,concurrency bugs at compile time.Don’t worry if those words are strange to you as they are explained in next blog post with rust code examples.Rust includes documentation about <a href="https://doc.rust-lang.org/error_codes/error-index.html">compile errors</a>.</p>
<p>Rust <strong>wasm-bindgen</strong> library generate <strong><a href="https://webassembly.org/">Webassembly</a></strong>.It’s a portable runtime for web, desktop, cloud, and blockchain where isolation and startup time is important. Rust has the best toolchain for web assembly than other languages. Web assembly runtime <em>wasmtime, Cranelift</em> itself is written in rust.</p>
<p>Because most of the errors are moved to compile time ,they are unlikely to crash at runtime and thus reliable for embedded systems reliable.Like haskell once it’s compiled it’s just work.</p>
<p>Last but not least Rust is a <strong><a href="https://dl.acm.org/doi/10.1145/3136014.3136031">green language</a></strong> i.e it’s very <strong>energy efficient</strong> after c.It’s important characteristic to consider since most of the world communicates through software.It’s impact is huge since IoT is on scale of billions thus reducing carbon footprints as well as providing safety.In the case of cloud computing writing software in rust means low carbon footprints like c but safety as well as less cloud bills as rust consume less memories.</p>
<p>I think that <strong>rust</strong> is going to be a <strong>programming language</strong> that c++ creator <em>anticipated</em> in his paper “History of c++” at end of the paper.</p>
<p>The trade off that accepts before rust came:</p>
<p><strong>Speed, safety,Easy to use</strong>-Pick any two.Language tends to provide <strong>safety, easy of use</strong> like python,java,js but not speed. Languages like c/c++ provide <strong>speed but unsafe</strong>.For Rust -Pick three but at what cost.Rust puts lot of restrictions on the programmer side so it’s essential to learn foundational concepts of rust <em>upfront</em> to successfully compile the rust code. This is very cumbersome if you are coming from dynamic programming languages like python,java script,ruby.Stay patient,listen to the compiler and fix it.</p>
<section id="resources-for-further-learning-about-rust" class="level2">
<h2 class="anchored" data-anchor-id="resources-for-further-learning-about-rust">Resources for further learning about rust</h2>
<p>Open the link in a new tab by holding ‘ctrl’ and then click the link,if you are using a mouse then just click a rolling button.</p>
<p><a href="https://rust-lang.org">Rust official Website</a></p>
<p><a href="https://doc.rust-lang.org/book/">Free high quality Rust book</a></p>
<p><a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">Programming rust book</a></p>
<p><a href="https://www.nature.com/articles/d41586-020-03382-2">Why scientist turns into rust by Nature</a></p>
<p><a href="https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/">Why rust so popular by stackoverflow</a></p>
<p><a href="https://blog.rust-lang.org/2014/10/30/Stability.html">Stability Without stagnation</a></p>
<p><a href="https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html">Rust Ergonomics</a></p>
<p><a href="https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html">Seamless Integration with c</a></p>
<p><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwiywIqwmab8AhWn2DgGHVPKBYQQFnoECCsQAQ&amp;url=https%3A%2F%2Fwww.stroustrup.com%2Fhopl2.pdf&amp;usg=AOvVaw3plr2I2rXY4sbYfqb3dGKs">History of c++</a></p>
<p><a href="https://discord.com/blog/why-discord-is-switching-from-go-to-rust">Why Discord is switching from Go to Rust</a>.</p>
<p><a href="https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext">Safe System Programming in Rust</a>.</p>
<p><a href="https://aws.amazon.com/blogs/opensource/sustainability-with-rust/">Energy efficiency of Rust by amazon blog</a></p>


</section>

 ]]></description>
  <category>Theory</category>
  <guid>https://sanjuvi.github.io/Blog/posts/Rust-pl/index.html</guid>
  <pubDate>Sun, 01 Jan 2023 08:00:00 GMT</pubDate>
  <media:content url="https://sanjuvi.github.io/Blog/posts/Rust-pl/image.svg" medium="image" type="image/svg+xml"/>
</item>
<item>
  <title>Zero Cost Abstraction</title>
  <dc:creator>Sanjeevi </dc:creator>
  <link>https://sanjuvi.github.io/Blog/posts/Zero-cost-abstraction/index.html</link>
  <description><![CDATA[ 




<p>Zero cost abstraction is a memory model for the system programming language that provides abstraction equivalent to handwritten low-level code without any additional overhead, proposed by Stroustrup in his paper Abstraction and C++ machine model. Let’s decompose them to explain their properties.</p>
<p><strong>Zero</strong>:</p>
<blockquote class="blockquote">
<p>What you do use, you couldn’t hand code any better.</p>
</blockquote>
<p>It’s still costly but compared to other high-level languages(Python, Java, C#) they have little overhead when using virtual dispatch. Once the c/c++ compiler emits the assembly from the source code through <em>GCC or LLVM</em> the compiler is no longer needed which means we can distribute executable files without the end user installing c/c++.Whereas in dynamic programming languages the source code and the language runtime must always sit behind to run the program. Just because we have lots of memory that doesn’t mean use all of that, that’s what garbage collectors do. Whereas in embedded systems memory is measured in KiloBytes rather than GigaBytes, TeraBytes in PC, supercomputers in that GC is not an option other than using c/c++ or now rust. It’s fast as the hardware allowed.</p>
<p><strong>Cost</strong>:</p>
<blockquote class="blockquote">
<p>What you don’t use, you don’t pay for.</p>
</blockquote>
<p>Every computation we perform has a cost associated with it, and how many resources(time and space) are needed to run a particular kind of task? Garbage-collected languages take more memory than necessary than manual memory management languages like c,c++, and rust.</p>
<p><strong>Abstraction</strong> :</p>
<ul>
<li><p>Modularity: Large code bases must be organized to reason about, and reused later. Adding new features doesn’t affect the rest of the code base. Aid in good API design. It’s not always possible to provide abstraction for all kinds of tasks. For eg Linux kernel uses a little bit of assembly in it, which is hard to abstract but uses assembly.</p></li>
<li><p>Less code maintenance. Rust features include Enums to write your intention compactly, Derive Macros to generate boilerplate code at compile time, and Generics to reduce the code lines but also the safety checking along the way.</p></li>
<li><p>Python and Js provide the highest level of abstraction which hides lots of complexity like Pointers, and Dynamic Memory allocation thus lacking control over hardware and instead preferring the ease of use, learning, and prototyping over runtime performance.</p></li>
<li><p>Exposing low-level details to the end user would mess up the hardware resources if they were using it inappropriately. For example at a low level, the alignment of the bit must be multiple by the size of the data type and power of two. If we design an API in a way that refuses to compile if violating the requirements. In this way abstraction provides security. The same is true for kernels, CUDA, and Operations on a type.</p></li>
<li><p>Source Level compatibility and portability(API)-Standard libraries(C++ templates, iterators) use an os specific libraries to implement functionality like a filesystem, and networks but at the source level they are identical APIs but under the hood (conditional compilation) they are different. This makes code portable, and less maintenance, No need to learn new APIs for each platform except for architecture-specific features.</p></li>
<li><p>Least level of abstraction provided by Assembly.</p></li>
</ul>
<section id="other-languages-that-are-used-in-embedded-systems" class="level2">
<h2 class="anchored" data-anchor-id="other-languages-that-are-used-in-embedded-systems">Other languages that are used in embedded systems:</h2>
<p><a href="https://www.adacore.com/about-spark">Ada</a> <a href="https://dlang.org/">D</a> <a href="https://ivorylang.org">Ivory</a></p>
</section>
<section id="cpu-chip-architecture" class="level2">
<h2 class="anchored" data-anchor-id="cpu-chip-architecture">CPU Chip Architecture</h2>
<p>Each CPU architecture has different assembly instructions, some are backward compatible others don’t. The compiler is a complex piece of software that does the heavy work of converting high-level concepts to architecture-specific assembly. Below are the most used CPU architectures and their 32 and 64-bit variants.</p>
<ul>
<li>Intel</li>
<li>AMD</li>
<li>Arm</li>
<li>PowerPC(IBM)</li>
<li>Alpha</li>
<li>Apple Silicon(Only available in Apple products)</li>
<li>Risc -v(Opensource Instruction Set Architecture(ISA)))</li>
</ul>
<p>It’s misleading when people say c++ is platform-dependent, but java has a famous quote that “Write once, run anywhere”.A lot of the complexity is abstracted away from the programmer by the java runtime libraries.Java Runtime converts platform-independent byte code into machine-specific instruction at runtime.</p>
<p>If Manual memory management is more efficient then why do we have GCed language in the first place? The software runs the world, it is important to write software that is memory-safe since writing memory-safety software in a system programming language leads to vulnerability because of the way the language is designed. Lots of series vulnerabilities are found in c/c++ code bases.GCed language prefers safety over runtime performance. But <strong>rust</strong> came to break that tradeoff as we will see in the next article.</p>
</section>
<section id="pros-of-managed-or-gced-language" class="level1">
<h1>Pros of managed or GCed language</h1>
<p>No need to worry about memory-related bugs at runtime(though not all bugs are addressed by GC). Instead, focus on the problem you want to solve rather than weird problems.</p>
</section>
<section id="pros-of-manual-memory-management" class="level1">
<h1>Pros of Manual Memory Management</h1>
<p>Predictable performance of memory allocation and deallocation thus efficient use of resources.</p>
<p>A program’s performance can be improved if most of the bugs are moved to compile time rather than runtime. For example <em>safe</em> <strong>rust</strong> refuse to compile if the program has a dangling pointer and other memory error.</p>
<p>I hope you understand the reason why c/c++ is used to write operating systems, kernels, boot loaders, networking, file systems, database, game engines ,embedded systems and many low-level kinds of stuff that get the most out of available hardware without imposing any additional overhead even though they are unsafe.</p>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li><a href="https://blog.rust-lang.org/2015/05/11/traits.html" target="_blank">Zero cost abstraction in Rust blog</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/11535409_1" target="_blank">Abstraction and C++ machine model stroustrup 2005</a></li>
</ul>


</section>
</section>

 ]]></description>
  <category>Theory</category>
  <guid>https://sanjuvi.github.io/Blog/posts/Zero-cost-abstraction/index.html</guid>
  <pubDate>Sat, 31 Dec 2022 08:00:00 GMT</pubDate>
  <media:content url="https://sanjuvi.github.io/Blog/posts/Zero-cost-abstraction/image.jpg" medium="image" type="image/jpeg"/>
</item>
</channel>
</rss>
