<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Home</title>
<link>https://sanjuvi.github.io/Blog/index.html</link>
<atom:link href="https://sanjuvi.github.io/Blog/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.2.280</generator>
<lastBuildDate>Sat, 31 Dec 2022 18:30:00 GMT</lastBuildDate>
<item>
  <title>What is Rust?</title>
  <dc:creator>Sanjeevi </dc:creator>
  <link>https://sanjuvi.github.io/Blog/posts/Rust-pl/index.html</link>
  <description><![CDATA[ 




<p><strong>Rust</strong> is an emerging new system programming language. But what is a system programming language? A system programming language is like any other programming language except it provides full control over hardware, manual memory management, abstraction without overhead like c++ to implement system-level software, and runs on bare metal(Without any operating system). So why another system programming language since we have c/c++?</p>
<p><strong>What others tell about rust</strong></p>
<blockquote class="blockquote">
<p>Linus Torvalds, the creator of Linux, considers rust as a second language for kernel development. This is somewhat intriguing since Linux doesn’t consider c++ as a secondary language</p>
</blockquote>
<p>The quotes below are from Microsoft Azure CTO Mark Russinovich in Twitter.</p>
<blockquote class="blockquote">
<p>Speaking of languages, it’s time to halt starting any new projects in C/C++ and use Rust for those scenarios where a non-GC language is required. For the sake of security and reliability. the industry should declare those languages as deprecated.</p>
</blockquote>
<blockquote class="blockquote">
<p>The microsoft Security Response Center (MSRC) stated “we think that Rust represents the best alternative to C and C++ currently available.</p>
</blockquote>
<p>Rust is most loved by developers for five years row, a survey conducted by StackOverflow.</p>
<p>now look at the feature, the language provides.</p>
<p><strong>Zero cost abstraction</strong> Abstraction in <em>the system</em> programming language doesn’t impose any additional overhead. Because it’s a system programming language introducing abstraction means reducing the development time, less code, expressive.More on <a href="https://sanjuvi.github.io/Blog/posts/Zero-cost-abstraction/">here</a>.</p>
<p><strong>AOT</strong>(Ahead of Time)</p>
<p>Rust compiler(rustc) is a gatekeeper to refuse a code that violates the compiler rules without even running a program thus the execution and startup speed is low once an executable file is generated.</p>
<p><strong>Guaranteed memory safety</strong></p>
<ul>
<li>Dangling pointer, double free, and null pointer dereferences are memory errors that are detected at compile time i.e the code with these errors doesn’t compile. Integer overflow and buffer overflow are detected at runtime, causing the rust program to panic at runtime instead of continuing with the wrong input which leads to undefined behavior. As long as the unsafe sound we are free of memory-related bugs.</li>
</ul>
<p><strong>Move Semantics</strong></p>
<ul>
<li>In rust, a type either copies or move. This distinction makes certain behavior injected when variables go out of scope by the compiler without the programmer’s intent. Primitive types like Int, Float, bool, and char are copy types i.e they are cheap to make a copy. Dynamically allocated types are movable i.e when assigned to a new variable, the old one is uninitialized, this prevents double-free error since only one owner for the variable except for smart pointers.</li>
</ul>
<p><strong>Fearless concurrency</strong>.</p>
<ul>
<li><p>Today consumer pc hardware brings more cores than a fast processor. Concurrency is way to increase throughput of a program.But implementing concurrency have its own risk like <em>race condition</em> (ordering of task is nondeterministic),<em>data races</em> (multiple threads are accessing and writing to same memory without synchronization which leads to data inconsistent), <em>Deadlock</em> (form cycle prevent to release memory thus leads memory leaks).Cncurrency in rust is a low-risk operation than c/c++,java since rustc has your back.</p></li>
<li><p>Concurrency bug is detected at <strong>compile time</strong>. This is significant because concurrency bugs are much harder to reproduce as they were time-dependent (non-deterministic).There are libraries that rust provides to implement synchronization and lock-free concurrency safely without any data corruption whatsoever.</p></li>
</ul>
<p><strong>Tools and productivity</strong></p>
<p><em>Cargo</em> -a build tool and a package manager like Pip for python,Npm fo js but for a system PL since c/c++ doesn’t have universal supports(Make,Microsoft c++ package manager).</p>
<p><em>Clippy</em> command used to find non-idiomatic rust like ESLinter for js.</p>
<p><em>Rustfmt</em> command line tool to standardize coding style like pretty quick for js.</p>
<p><em>Rustup</em> -Command line tool to install rust, rust components cargo,targets for cross-compilation, change the rustc version(stable,nightly,beta)</p>
<p><em>Rust Language Server(rls)</em> used in intelligence IDE to provide syntax highlighting,code completion, pointing errors.</p>
<p><em>Rust Docs</em> includes std library documentation, rust book, rust reference book when installing rust locally.</p>
<p><em>RustDoc</em> Generating documents embedded in rust source code via ‘///’ and then rendering on Doc.rs</p>
<p>Build in testing framework via <em>test</em> macros.</p>
<p>Module system to manage large programs.</p>
<p>Because rust is a system programming language it supports conditional compilation,staticlib,dynamic link library.</p>
<p><em><a href="play.rust-lang.org/">Rust playground</a></em> for playing with the language instantly in the web browser without installing rust locally.</p>
<p>Rust is a modern system programming language in addition to memory safe <strong>without using Garbage Collector</strong>. Is modern in the sense that these features are available in high-level dynamic programming languages not implemented in system programming languages. Functional programming features are included (In the context of Haskell-a pure functional programming language)</p>
<ul>
<li><p>Unit type-A function without explicit return type returns unit type ‘()-an empty tuple’.It’s like a void in c/c++</p></li>
<li><p>pattern matching-Pattern must be exhaustive,cover all possible cases otherwise get a compile error.</p></li>
<li><p>Algebraic data types(Enums)-This is useful in handling errors since rust doesn’t have a nullpointer. Super handy with pattern matching.</p></li>
<li><p>lazy evaluation-Iterators in rust are lazy, they are evaluated as they are requested not at once unless consumed otherwise.</p></li>
<li><p>Rust is an expression-oriented language. This makes the code look cleaner.</p></li>
<li><p>Traits are equivalent to type classes in Haskell.</p></li>
<li><p>Type aliasing increase the readability by making long names with short name wherever they are used.</p></li>
<li><p>Immutability,type deduction,error as code.</p></li>
</ul>
<p><strong>Other Features and Community</strong></p>
<p>Supports <em>UTF-8</em> out of the box. Thus we can use more languages other than English. We can use emojis, scientific symbols, and other foreign languages.</p>
<p><strong>Ergonomics</strong> to use language features than in the c/c++ counterparts.</p>
<p><em>Generics</em> Reduce code duplication. Supports static dispatch along with compiler optimization and virtual dispatch via trait object at runtime.</p>
<p><em>Hygienic Macros</em>-To generate boilerplate rust code for you , expanded when compiling so your code looks clean.</p>
<p><em>Closure</em> anonymous function.You can do an interesting thing with them without worrying about safety.</p>
<p><em>Robust error handling strategies</em> through Result &amp; Option Type,using from ,into traits through ? operator.You never forgot to check error as the compiler forces you to do it ,the exhaustive nature of pattern matching.</p>
<p><em><a href="https://crates.io">Crates.io</a></em> a package registry for rust opensource libraries which cargo uses interanlly when building.</p>
<p><em>Backward compatibility</em>-This is important for evolving language feature as well as not breaking the code due to introducing new features into the language.This is reason why c/C++ barely introduces any major features or it will break the old code since it’s already span millions of lines of code in production.</p>
<p><strong>Automatic scoped management</strong> for memory ,non_memory resources,locks,smart pointers are phenomenal since no human intervention is needed and also no runtime cost for that(More on that later).It’s <em>RAII</em>(Resource acquistion is initialization) principle from c++ for managing resources.</p>
<p><em><a href="https://foundation.rust-lang.org/">Rust Foundation</a></em> is backed by big players that include Microsoft, Meta, Dropbox, Arm, Google, Amazon ,Shopify and others.Rust is a future-proof language.</p>
<p><em>Compile errors</em> contain rich information about what went wrong ,where that happened if code doesn’t compile and also suggests fixing that.This is important since rust introduces unique concepts Like <strong>ownership, borrowing,lifetime</strong> to rule out use after free, double free, dangling pointer, iterator invalidation,concurrency bugs at compile time.Don’t worry if those words are strange to you as they are explained in next blog post with rust code examples.Rust includes documentation about <a href="https://doc.rust-lang.org/error_codes/error-index.html">compile errors</a>.</p>
<p>Rust <strong>wasm-bindgen</strong> library generate <strong><a href="https://webassembly.org/">Webassembly</a></strong>.It’s a portable runtime for web, desktop, cloud, and blockchain where isolation and startup time is important. Rust has the best toolchain for web assembly than other languages. Web assembly runtime <em>wasmtime, Cranelift</em> itself is written in rust.</p>
<p>Because most of the errors are moved to compile time ,they are unlikely to crash at runtime and thus reliable for embedded systems reliable.Like haskell once it’s compiled it’s just work.</p>
<p>Last but not least Rust is a <strong><a href="https://dl.acm.org/doi/10.1145/3136014.3136031">green language</a></strong> i.e it’s very <strong>energy efficient</strong> after c.It’s important characteristic to consider since most of the world communicates through software.It’s impact is huge since IoT is on scale of billions thus reducing carbon footprints as well as providing safety.In the case of cloud computing writing software in rust means low carbon footprints like c but safety as well as less cloud bills as rust consume less memories.</p>
<p>I think that <strong>rust</strong> is going to be a <strong>programming language</strong> that c++ creator <em>anticipated</em> in his paper “History of c++” at end of the paper.</p>
<p>The trade off that accepts before rust came:</p>
<p><strong>Speed, safety,Easy to use</strong>-Pick any two.Language tends to provide <strong>safety, easy of use</strong> like python,java,js but not speed. Languages like c/c++ provide <strong>speed but unsafe</strong>.For Rust -Pick three but at what cost.Rust puts lot of restrictions on the programmer side so it’s essential to learn foundational concepts of rust <em>upfront</em> to successfully compile the rust code. This is very cumbersome if you are coming from dynamic programming languages like python,java script,ruby.Stay patient,listen to the compiler and fix it.</p>
<section id="resources-for-further-learning-about-rust" class="level2">
<h2 class="anchored" data-anchor-id="resources-for-further-learning-about-rust">Resources for further learning about rust</h2>
<p>Open the link in a new tab by holding ‘ctrl’ and then click the link,if you are using a mouse then just click a rolling button.</p>
<p><a href="https://rust-lang.org">Rust official Website</a></p>
<p><a href="https://doc.rust-lang.org/book/">Free high quality Rust book</a></p>
<p><a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">Programming rust book</a></p>
<p><a href="https://www.nature.com/articles/d41586-020-03382-2">Why scientist turns into rust by Nature</a></p>
<p><a href="https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/">Why rust so popular by stackoverflow</a></p>
<p><a href="https://blog.rust-lang.org/2014/10/30/Stability.html">Stability Without stagnation</a></p>
<p><a href="https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html">Rust Ergonomics</a></p>
<p><a href="https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html">Seamless Integration with c</a></p>
<p><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwiywIqwmab8AhWn2DgGHVPKBYQQFnoECCsQAQ&amp;url=https%3A%2F%2Fwww.stroustrup.com%2Fhopl2.pdf&amp;usg=AOvVaw3plr2I2rXY4sbYfqb3dGKs">History of c++</a></p>
<p><a href="https://discord.com/blog/why-discord-is-switching-from-go-to-rust">Why Discord is switching from Go to Rust</a>.</p>
<p><a href="https://dl.acm.org/doi/10.1145/3139645.3139660">System Programming in Rust:Beyond Safety</a>.Use this <a href="sci-hub.se/">link</a> to download the paper.</p>
<p><a href="https://aws.amazon.com/blogs/opensource/sustainability-with-rust/">Energy efficiency of Rust by amazon blog</a></p>


</section>

 ]]></description>
  <category>Theory</category>
  <guid>https://sanjuvi.github.io/Blog/posts/Rust-pl/index.html</guid>
  <pubDate>Sat, 31 Dec 2022 18:30:00 GMT</pubDate>
  <media:content url="https://sanjuvi.github.io/Blog/posts/Rust-pl/image.svg" medium="image" type="image/svg+xml"/>
</item>
<item>
  <title>Zero Cost Abstraction</title>
  <dc:creator>Sanjeevi </dc:creator>
  <link>https://sanjuvi.github.io/Blog/posts/Zero-cost-abstraction/index.html</link>
  <description><![CDATA[ 




<p>Zero cost abstraction is a memory model for the system programming language that provides abstraction equivalent to handwritten low-level code without any additional overhead, proposed by Stroustrup in his paper Abstraction and C++ machine model. Let’s decompose them to explain their properties.</p>
<p><strong>Zero</strong>:</p>
<blockquote class="blockquote">
<p>What you do use, you couldn’t hand code any better.</p>
</blockquote>
<p>It’s still costly but compared to other high-level languages(Python, Java, C#) they have little overhead when using virtual dispatch. Once the c/c++ compiler emits the assembly from the source code through <em>GCC or LLVM</em> the compiler is no longer needed which means we can distribute executable files without the end user installing c/c++.Whereas in dynamic programming languages the source code and the language runtime must always sit behind to run the program. Just because we have lots of memory that doesn’t mean use all of that, that’s what garbage collectors do. Whereas in embedded systems memory is measured in KiloBytes rather than GigaBytes, TeraBytes in PC, supercomputers in that GC is not an option other than using c/c++ or now rust. It’s fast as the hardware allowed.</p>
<p><strong>Cost</strong>:</p>
<blockquote class="blockquote">
<p>What you don’t use, you don’t pay for.</p>
</blockquote>
<p>Every computation we perform has a cost associated with it, and how many resources(time and space) are needed to run a particular kind of task? Garbage-collected languages take more memory than necessary than manual memory management languages like c,c++, and rust.</p>
<p><strong>Abstraction</strong> :</p>
<ul>
<li><p>Modularity: Large code bases must be organized to reason about, and reused later. Adding new features doesn’t affect the rest of the code base. Aid in good API design. It’s not always possible to provide abstraction for all kinds of tasks. For eg Linux kernel uses a little bit of assembly in it, which is hard to abstract but uses assembly.</p></li>
<li><p>Less code maintenance. Rust features include Enums to write your intention compactly, Derive Macros to generate boilerplate code at compile time, and Generics to reduce the code lines but also the safety checking along the way.</p></li>
<li><p>Python and Js provide the highest level of abstraction which hides lots of complexity like Pointers, and Dynamic Memory allocation thus lacking control over hardware and instead preferring the ease of use, learning, and prototyping over runtime performance.</p></li>
<li><p>Exposing low-level details to the end user would mess up the hardware resources if they were using it inappropriately. For example at a low level, the alignment of the bit must be multiple by the size of the data type and power of two. If we design an API in a way that refuses to compile if violating the requirements. In this way abstraction provides security. The same is true for kernels, CUDA, and Operations on a type.</p></li>
<li><p>Source Level compatibility and portability(API)-Standard libraries(C++ templates, iterators) use an os specific libraries to implement functionality like a filesystem, and networks but at the source level they are identical APIs but under the hood (conditional compilation) they are different. This makes code portable, and less maintenance, No need to learn new APIs for each platform except for architecture-specific features.</p></li>
<li><p>Least level of abstraction provided by Assembly.</p></li>
</ul>
<section id="other-languages-that-are-used-in-embedded-systems" class="level2">
<h2 class="anchored" data-anchor-id="other-languages-that-are-used-in-embedded-systems">Other languages that are used in embedded systems:</h2>
<p><a href="https://www.adacore.com/about-spark">Ada</a> <a href="https://dlang.org/">D</a> <a href="https://ivorylang.org">Ivory</a></p>
</section>
<section id="cpu-chip-architecture" class="level2">
<h2 class="anchored" data-anchor-id="cpu-chip-architecture">CPU Chip Architecture</h2>
<p>Each CPU architecture has different assembly instructions, some are backward compatible others don’t. The compiler is a complex piece of software that does the heavy work of converting high-level concepts to architecture-specific assembly. Below are the most used CPU architectures and their 32 and 64-bit variants.</p>
<ul>
<li>Intel</li>
<li>AMD</li>
<li>Arm</li>
<li>PowerPC(IBM)</li>
<li>Alpha</li>
<li>Apple Silicon(Only available in Apple products)</li>
<li>Risc -v(Opensource Instruction Set Architecture(ISA)))</li>
</ul>
<p>It’s misleading when people say c++ is platform-dependent, but java has a famous quote that “Write once, run anywhere”.A lot of the complexity is abstracted away from the programmer by the java runtime libraries.Java Runtime converts platform-independent byte code into machine-specific instruction at runtime.</p>
<p>If Manual memory management is more efficient then why do we have GCed language in the first place? The software runs the world, it is important to write software that is memory-safe since writing memory-safety software in a system programming language leads to vulnerability because of the way the language is designed. Lots of series vulnerabilities are found in c/c++ code bases.GCed language prefers safety over runtime performance. But <strong>rust</strong> came to break that tradeoff as we will see in the next article.</p>
</section>
<section id="pros-of-managed-or-gced-language" class="level1">
<h1>Pros of managed or GCed language</h1>
<p>No need to worry about memory-related bugs at runtime(though not all bugs are addressed by GC). Instead, focus on the problem you want to solve rather than weird problems.</p>
</section>
<section id="pros-of-manual-memory-management" class="level1">
<h1>Pros of Manual Memory Management</h1>
<p>Predictable performance of memory allocation and deallocation thus efficient use of resources.</p>
<p>A program’s performance can be improved if most of the bugs are moved to compile time rather than runtime. For example <em>safe</em> <strong>rust</strong> refuse to compile if the program has a dangling pointer and other memory error.</p>
<p>I hope you understand the reason why c/c++ is used to write operating systems, kernels, boot loaders, networking, file systems, database, game engines ,embedded systems and many low-level kinds of stuff that get the most out of available hardware without imposing any additional overhead even though they are unsafe.</p>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li><a href="https://blog.rust-lang.org/2015/05/11/traits.html" target="_blank">Zero cost abstraction in Rust blog</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/11535409_1" target="_blank">Abstraction and C++ machine model stroustrup 2005</a></li>
</ul>


</section>
</section>

 ]]></description>
  <category>Theory</category>
  <guid>https://sanjuvi.github.io/Blog/posts/Zero-cost-abstraction/index.html</guid>
  <pubDate>Fri, 30 Dec 2022 18:30:00 GMT</pubDate>
  <media:content url="https://sanjuvi.github.io/Blog/posts/Zero-cost-abstraction/image.jpg" medium="image" type="image/jpeg"/>
</item>
</channel>
</rss>
